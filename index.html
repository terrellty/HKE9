<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>HKE九張（測試中）</title>

  <!-- PWA / iOS WebApp meta -->
  <link rel="manifest" href="./manifest.webmanifest" />
  <meta name="theme-color" content="#064e3b" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="HKE九張" />
  <link rel="icon" href="./icon.svg" type="image/svg+xml" />
  <link rel="apple-touch-icon" href="./icon.svg" />

  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <style>
    html, body { height: 100%; touch-action: manipulation; }
    button, input, select { touch-action: manipulation; }
    .card { user-select: none; -webkit-user-select: none; }
    .mono { font-variant-numeric: tabular-nums; }

    /* Poker card look */
    .poker-card {
      position: relative;
      background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
      border: 1px solid rgba(15,23,42,.22);
      border-radius: 14px;
      box-shadow: 0 10px 22px rgba(0,0,0,.18);
      overflow: hidden;
    }
    .poker-card::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 13px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.75);
      pointer-events: none;
    }
    .poker-card:active { transform: scale(.99); }

    .pcorner {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      line-height: 1;
      font-weight: 900;
      letter-spacing: -0.02em;
      user-select: none;
    }
    .pcorner.tl { left: 6px; top: 6px; }
    .pcorner.br { display: none !important; }
    .pcorner .prank { font-size: 14px; }
    .pcorner .psuit { font-size: 14px; margin-top: 2px; }

    .pcenter {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-weight: 900;
      text-shadow: 0 6px 20px rgba(0,0,0,.12);
      user-select: none;
      pointer-events: none;
    }

    /* size tuning */
    /* Hand cards (in Hand Dock): compact to avoid covering arrange area */
    .poker-card.pc-hand .pcorner .prank { font-size: 11px; }
    .poker-card.pc-hand .pcorner .psuit { font-size: 11px; }
    .poker-card.pc-hand .pcenter { font-size: 40px; }

     /* --- 新的 pc-slot 設定 (加大) --- */
    .poker-card.pc-slot {
      /* 透過 CSS 定義基礎大小，JS 中也會有對應 class，這裡做雙重確保 */
      width: 50px; 
      height: 70px;
    }
    @media (min-width: 640px) {
      .poker-card.pc-slot {
        width: 58px; 
        height: 80px;
      }
    }

    .poker-card.pc-slot .pcorner .prank { font-size: 14px; }
    /* 隱藏右下角 */
    .poker-card.pc-slot .pcorner.br { display: none !important; }
    
    /* 極大化中間花色 */
    .poker-card.pc-slot .pcenter { 
      font-size: 40px; 
      line-height: 1;
    }

    /* Mini cards (table reveal) */
    .poker-card.pc-mini { border-radius: 6px; }
    .poker-card.pc-mini .pcorner.tl { left: 2px; top: 2px; }
    .poker-card.pc-mini .pcorner.br { right: 2px; bottom: 2px; }
    .poker-card.pc-mini .pcorner .prank { font-size: 7px; }
    .poker-card.pc-mini .pcorner .psuit { font-size: 7px; margin-top: 0px; }
    .poker-card.pc-mini .pcenter { font-size: 10px; }
    .poker-card.pc-mini.pc-joker .pcenter { font-size: 8px; letter-spacing: .02em; }

    /* Card back */
    .poker-card.card-back {
      background:
        radial-gradient(140px 90px at 40% 30%, rgba(250,204,21,.25), rgba(2,6,23,0) 60%),
        repeating-linear-gradient(45deg, #1d4ed8 0 6px, #0f172a 6px 12px);
      border-color: rgba(255,255,255,.18);
    }
    .poker-card.card-back::before {
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.25);
    }

    .poker-card.pc-joker .pcenter {
      font-size: 12px;
      letter-spacing: .10em;
    }

    /* Hand overlap (stacked/fanned) */
    #hand { align-items: flex-end; }
    /* tighter overlap for smaller hand cards */
    .hand-overlap { margin-left: -32px; }

    /* Kiosk-like fullscreen landscape */
    @media (orientation: portrait) {
      #rotateHint { display: flex !important; }
      #appRoot { display: none !important; }
    }

    /* "開心鬥一番" 風格：綠桌 + 金色點綴 */
    body {
      background:
        radial-gradient(1200px 600px at 50% -10%, rgba(34,197,94,.35), rgba(2,6,23,0) 55%),
        radial-gradient(800px 500px at 20% 10%, rgba(250,204,21,.20), rgba(2,6,23,0) 55%),
        radial-gradient(900px 650px at 80% 15%, rgba(59,130,246,.16), rgba(2,6,23,0) 60%),
        linear-gradient(180deg, #064e3b 0%, #052e24 40%, #020617 100%);
    }
    .panel {
      background: rgba(2,6,23,0.55);
      border: 1px solid rgba(250,204,21,0.18);
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
    }
    .chip {
      border: 1px solid rgba(250,204,21,.25);
      background: rgba(250,204,21,.08);
    }

    /* Modal backdrop */
    .backdrop {
      background: rgba(2,6,23,.72);
      backdrop-filter: blur(10px);
    }

    /* Fun animations */
    @keyframes dealIn {
      from { transform: translateY(12px) scale(.98); opacity: 0; }
      to { transform: translateY(0) scale(1); opacity: 1; }
    }
    .deal-card { animation: dealIn .35s ease-out both; }

    @keyframes modalUp {
      from { transform: translateY(18px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    .modal-in { animation: modalUp .22s ease-out both; }

    @keyframes glowPulse {
      0%,100% { box-shadow: 0 0 0 rgba(250,204,21,0); }
      50% { box-shadow: 0 0 28px rgba(250,204,21,.18); }
    }
    .glow-pulse { animation: glowPulse 1.4s ease-in-out infinite; }

    /* Chat unread indicator: whole button blink */
    @keyframes chatBtnPulse {
      0%, 100% { transform: translateY(0); filter: brightness(1); box-shadow: 0 0 0 rgba(250,204,21,0); }
      50% { transform: translateY(-1px); filter: brightness(1.15); box-shadow: 0 0 0 3px rgba(250,204,21,.18), 0 0 18px rgba(250,204,21,.22); }
    }
    #btnOpenLog.chat-unread {
      animation: chatBtnPulse 1s ease-in-out infinite;
      border-color: rgba(250,204,21,.35) !important;
      background: rgba(250,204,21,.10) !important;
    }

    /* Chat unread indicator for collapsed bar toggle */
    #btnShowBar.chat-unread {
      animation: chatBtnPulse 1s ease-in-out infinite;
      border-color: rgba(250,204,21,.35) !important;
      background: rgba(250,204,21,.10) !important;
    }

    /* Update available (lobby) */
    @keyframes updatePulse {
      0%,100% { transform: translateY(0); filter: brightness(1); box-shadow: 0 0 0 rgba(250,204,21,0); }
      50% { transform: translateY(-1px); filter: brightness(1.18); box-shadow: 0 0 0 3px rgba(250,204,21,.18), 0 0 18px rgba(250,204,21,.22); }
    }
    #btnUpdateApp.update-available {
      animation: updatePulse 1s ease-in-out infinite;
    }

    /* Danmaku */
    @keyframes danmakuFly {
      from { transform: translateX(110vw); }
      to { transform: translateX(-140%); }
    }
    .danmaku-item {
      position: absolute;
      left: 0;
      white-space: nowrap;
      padding: 6px 10px;
      border-radius: 9999px;
      background: rgba(2,6,23,.55);
      border: 1px solid rgba(250,204,21,.25);
      color: rgba(255,255,255,.98);
      font-weight: 900;
      letter-spacing: .02em;
      text-shadow: 0 2px 14px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      will-change: transform;
    }
    .danmaku-item.sticker { padding: 4px 8px; }
    .danmaku-item.sticker img {
      width: 88px;
      height: 88px;
      object-fit: contain;
      display: inline-block;
      vertical-align: middle;
    }

    .chat-sticker {
      width: 92px;
      height: 92px;
      object-fit: contain;
      border-radius: 14px;
      border: 1px solid rgba(250,204,21,.18);
      background: rgba(2,6,23,.25);
    }

    /* Table scene */
    .table-felt {
      background:
        radial-gradient(400px 260px at 50% 40%, rgba(250,204,21,.14), rgba(2,6,23,0) 65%),
        radial-gradient(900px 600px at 50% 50%, rgba(34,197,94,.22), rgba(2,6,23,0) 70%),
        linear-gradient(180deg, rgba(6,78,59,.55), rgba(2,6,23,.35));
    }

    @keyframes revealPop {
      from { transform: scale(.92); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    .reveal-fan { animation: revealPop .26s ease-out both; transform-origin: top center; }

    canvas.confetti {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 70;
    }

    /* Poop animation (seat prank) */
    @keyframes poopDrop {
      0% { transform: translate(-50%, -18px) scale(.55) rotate(-12deg); opacity: 0; }
      15% { opacity: 1; }
      60% { transform: translate(-50%, 12px) scale(1.08) rotate(10deg); }
      100% { transform: translate(-50%, 30px) scale(.92) rotate(0deg); opacity: 0; }
    }
    .poop-item {
      position: absolute;
      left: 50%;
      top: 6px;
      font-size: 26px;
      line-height: 1;
      pointer-events: none;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.45));
      animation: poopDrop 900ms cubic-bezier(.2,.9,.2,1) both;
      z-index: 3;
    }

    /* Poop projectile (throw) */
    .poop-throw {
      position: fixed;
      left: 0;
      top: 0;
      transform: translate(-50%, -50%);
      font-size: 28px;
      line-height: 1;
      pointer-events: none;
      z-index: 65;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.45));
      will-change: left, top, transform;
    }

    /* Hand dock safe-area */
    .hand-dock {
      padding-bottom: env(safe-area-inset-bottom);
    }
  </style>
</head>
<body class="text-slate-50 min-h-screen overflow-hidden">
  <!-- Rotate hint (portrait only) -->
  <div id="rotateHint" class="hidden fixed inset-0 z-[80] items-center justify-center p-6">
    <div class="rounded-2xl panel border border-amber-200/20 p-5 max-w-md w-full text-center">
      <div class="text-xs text-emerald-100/70">HKE九張｜全屏橫版</div>
      <div class="mt-2 text-lg font-black tracking-tight">請把手機轉為橫向</div>
      <div class="mt-2 text-sm text-emerald-50/80">為了方便牌桌操作，本 WebApp 只支援橫版全屏顯示。</div>
    </div>
  </div>

  <div id="appRoot" class="fixed inset-0">
    <div class="h-full max-w-none mx-auto p-0 relative">
      <div class="absolute top-2 left-2 z-[60]">
        <span id="netBadge" class="text-[11px] px-2 py-1 rounded-full chip text-amber-100">離線</span>
      </div>
      <div class="absolute top-2 right-2 z-[40]">
        <button id="btnGoLobby" class="hidden text-[11px] px-2.5 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">退出房間</button>
      </div>

      <!-- Lobby Page -->
    <main id="pageLobby" class="h-full">
      <section class="h-full rounded-none border-0 table-felt p-0">
        <div class="flex items-center justify-between gap-2 mb-2">
          <div class="text-[11px] text-emerald-100/80">大廳｜玩家圍桌</div>
          <div class="flex items-center gap-2">
            <div id="roleBadge" class="text-[11px] inline-flex px-2 py-1 rounded-full bg-black/30 border border-white/10 text-slate-100">未連線</div>
            <div class="text-[11px] text-emerald-100/70"><span id="playersCount">0</span> 人</div>
          </div>
        </div>

        <div class="relative w-full h-[calc(100%-32px)] max-w-none mx-auto">
          <div class="absolute inset-0">
            <div class="absolute inset-0 rounded-[28px] border border-amber-200/15 table-felt"></div>
          </div>

          <!-- Seats ring (rendered by JS) -->
          <div id="lobbySeats" class="absolute inset-0"></div>

          <!-- Center controls (HKE pot) -->
          <div class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[320px] sm:w-[360px]">
            <div class="rounded-2xl panel border border-amber-200/15 p-3">
              <div class="flex items-center justify-between gap-2">
                <div class="flex items-center gap-2">
                  <div class="rounded-full px-3 py-1 chip text-amber-100 text-xs font-black">HKE九張</div>
                  <button id="btnUpdateApp" type="button" class="text-[11px] px-2.5 py-1.5 rounded-full bg-amber-400/15 border border-amber-200/25 text-amber-100 font-black hover:brightness-110">更新</button>
                  <button id="btnOpenScoreboard" type="button" class="text-[11px] px-2.5 py-1.5 rounded-full bg-white/10 hover:bg-white/15 border border-white/10 text-emerald-50">計分版</button>
                </div>
                <div class="text-[11px] text-emerald-100/70">1.2.6</div>
              </div>

              <div class="mt-2 grid gap-2">
                <div class="grid gap-1">
                  <label class="text-[11px] text-emerald-100/70">暱稱</label>
                  <div class="flex gap-2">
                    <input id="inpName" class="flex-1 bg-black/35 border border-white/10 rounded-xl px-3 py-2 text-sm outline-none focus:border-amber-200/50" placeholder="例如：小明" maxlength="20" />
                    <button id="btnSaveName" class="px-3 py-2 rounded-xl bg-gradient-to-b from-amber-400 to-amber-500 text-slate-950 text-sm font-semibold hover:brightness-105">儲存</button>
                  </div>
                </div>

                <div class="grid gap-1">
                  <div class="flex items-center justify-between">
                    <label class="text-[11px] text-emerald-100/70">房間號（加入 / 建立）</label>
                    <label class="inline-flex items-center gap-1.5 text-[11px] text-emerald-100/80 select-none">
                      <input id="chkUseTurn" type="checkbox" class="accent-amber-400" />
                      TURN
                    </label>
                  </div>
                  <input id="inpRoomId" class="w-full mono bg-black/35 border border-white/10 rounded-xl px-3 py-2 outline-none focus:border-amber-200/50" placeholder="留空＝自動；填入＝指定房號" />
                  <div class="text-[10px] text-emerald-100/70">提示：跨網絡連不上時再勾 TURN（中繼）。</div>
                </div>

                <div class="flex gap-2">
                  <button id="btnCreateRoom" class="flex-1 px-4 py-2 rounded-xl bg-gradient-to-b from-emerald-400 to-emerald-500 text-emerald-950 font-semibold hover:brightness-105">建立</button>
                  <button id="btnJoinRoom" class="flex-1 px-4 py-2 rounded-xl bg-gradient-to-b from-sky-400 to-sky-500 text-sky-950 font-semibold hover:brightness-105">加入</button>
                  <button id="btnStartGame" class="hidden flex-1 px-4 py-2 rounded-xl bg-gradient-to-b from-indigo-400 to-indigo-500 text-indigo-950 font-semibold hover:brightness-105">開始</button>
                  <button id="btnLeave" class="hidden flex-1 px-4 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/10">離開</button>
                </div>

                <div class="flex items-center justify-between gap-2">
                  <div class="grid gap-1">
                    <label class="text-[11px] text-emerald-100/70">局數（5 的倍數）</label>
                    <input id="inpRounds" type="number" min="5" step="5" value="5" class="w-28 mono bg-black/35 border border-white/10 rounded-xl px-3 py-2 outline-none focus:border-amber-200/50" />
                    <label class="inline-flex items-center gap-2 text-[11px] text-emerald-100/80 select-none">
                      <input id="chkBBMode" type="checkbox" class="accent-amber-400" />
                      BB 模式（關閉排牌限時）
                    </label>
                  </div>
                  <button id="btnApplyRounds" class="hidden px-3 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/10 text-[11px]">套用</button>
                  <div class="text-right">
                    <div class="text-[10px] text-emerald-100/70">我的房號</div>
                    <div class="flex items-center gap-2">
                      <div id="myPeerId" class="mono text-[11px] px-2 py-1 rounded-lg bg-black/30 border border-white/10 text-slate-100">—</div>
                      <button id="btnCopyRoom" class="hidden text-[11px] px-2.5 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">複製</button>
                      <button id="btnCopyLink" class="hidden text-[11px] px-2.5 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">連結</button>
                    </div>
                  </div>
                </div>

                <details class="hidden rounded-xl bg-black/20 border border-white/10 p-2">
                  <summary class="cursor-pointer select-none text-[11px] text-emerald-100/80">更多設定（進階連線）</summary>
                  <div class="mt-2 grid gap-2">
                    <div class="grid gap-1">
                      <label class="text-[11px] text-emerald-100/70">TURN URL（選填）</label>
                      <input id="inpTurnUrl" class="mono bg-black/35 border border-white/10 rounded-xl px-3 py-2 outline-none focus:border-amber-200/50" placeholder="turns:your-domain:5349 或 turn:ip:3478" maxlength="120" />
                    </div>
                    <div class="grid sm:grid-cols-2 gap-2">
                      <div class="grid gap-1">
                        <label class="text-[11px] text-emerald-100/70">TURN Username（選填）</label>
                        <input id="inpTurnUser" class="mono bg-black/35 border border-white/10 rounded-xl px-3 py-2 outline-none focus:border-amber-200/50" placeholder="username" maxlength="80" />
                      </div>
                      <div class="grid gap-1">
                        <label class="text-[11px] text-emerald-100/70">TURN Password（選填）</label>
                        <input id="inpTurnPass" type="password" class="mono bg-black/35 border border-white/10 rounded-xl px-3 py-2 outline-none focus:border-amber-200/50" placeholder="password" maxlength="80" />
                      </div>
                    </div>
                    <label class="inline-flex items-center gap-2 text-[11px] text-emerald-100/80">
                      <input id="chkRelayOnly" type="checkbox" class="accent-amber-400" />
                      優先使用中繼（relay-only，需要 TURN；延遲會增加）
                    </label>
                    <div class="flex flex-wrap items-center gap-2">
                      <button id="btnSaveNet" class="text-[11px] px-3 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">儲存</button>
                      <button id="btnClearNet" class="text-[11px] px-3 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">恢復預設</button>
                      <button id="btnTestTurn" class="text-[11px] px-3 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">測試 TURN</button>
                    </div>
                    <div id="turnTestStatus" class="text-[11px] text-emerald-100/70">TURN 測試：尚未測試</div>
                  </div>
                </details>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Hide non-table sections in kiosk mode -->
      <div class="hidden">
        <details class="rounded-2xl panel p-4">
          <summary class="cursor-pointer select-none text-sm text-slate-100">玩家列表（詳細）</summary>
          <div id="playersList" class="mt-3 grid gap-2"></div>
        </details>
        <section class="rounded-2xl panel p-4">
          <div class="flex items-center justify-between">
            <h2 class="font-semibold">事件紀錄</h2>
            <button id="btnClearLog" class="text-xs px-3 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">清空</button>
          </div>
          <div id="log" class="mt-3 text-xs text-emerald-50/80 space-y-1 max-h-56 overflow-auto"></div>
        </section>
      </div>
    </main>

    <!-- Game Page -->
    <main id="pageGame" class="hidden h-full">
      <!-- Table-only screen (kiosk) -->
      <div class="h-full rounded-none border-0 table-felt p-0">
        <div id="tableSeats" class="relative w-full h-full max-w-none mx-auto">
          <!-- Center pot / action hotspot -->
          <button id="btnOpenActionMenu" type="button" class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-full px-6 py-3 chip text-amber-100 text-sm font-black hover:brightness-110 active:scale-[0.99] transition">
            HKE九張
          </button>
        </div>

        <!-- small status line (kiosk) -->
        <div class="absolute left-2 bottom-2 text-[11px] text-emerald-100/70">
          <span id="foulHint">擺烏龍：頭 &gt; 中 或 中 &gt; 尾（允許提交；結算時處理）</span>
          <span class="mx-2">｜</span>
          你的提交：<span id="submitStatus" class="text-emerald-50/80">尚未提交</span>
        </div>
      </div>

      <!-- Hand Dock (fixed, above bottom bar) - only shown while Arrange Modal is open -->
      <!-- 1. 外層修改：left-1/2 -translate-x-1/2 (置中) 以及 w-3/4 (75%寬度) -->
<div id="handDock" class="hand-dock fixed left-1/2 -translate-x-1/2 bottom-0 translate-y-4 z-[56] hidden pointer-events-none w-3/4">
  
  <div class="mx-auto w-full px-2 pb-2 pointer-events-auto">
    <div class="rounded-2xl p-0"> 
      
      <!-- 2. 內層修改：移除 [&>*]:shrink-0，保留 flex-nowrap -->
      <!-- 這樣當卡片數量多時，瀏覽器會嘗試壓縮卡片寬度來塞進容器 -->
      <div id="hand" class="flex gap-0 overflow-x-auto overflow-y-hidden pl-1 pr-10 pb-4 flex-nowrap min-h-[110px] items-end">
        <!-- 這裡面的內容會自動被壓縮 -->
      </div>
      
    </div>
  </div>
</div>

      <!-- Bottom action bar (mobile friendly) -->
      <div id="bottomBar" class="fixed bottom-0 left-0 right-0 z-[45]">
        <div class="mx-auto max-w-5xl px-3 pb-3">
          <div class="rounded-2xl panel border border-white/10 p-2 flex items-center gap-2">
            <button id="btnOpenStatus" class="flex-1 text-xs px-3 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/10">狀態/結果</button>
            <button id="btnMidAction" class="flex-1 text-xs px-3 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/10">牌組</button>
            <button id="btnOpenLog" class="flex-1 text-xs px-3 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/10">聊天</button>
            <button id="btnHideBar" class="shrink-0 w-10 text-xs px-0 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/10">&gt;</button>
          </div>
        </div>
      </div>

      <!-- Show bottom bar button (hidden by default; only visible when bottom bar is collapsed) -->
      <button id="btnShowBar" type="button" class="hidden fixed bottom-3 right-3 z-[46] w-11 h-11 rounded-full chip text-amber-100 font-black border border-amber-200/20 bg-black/25 backdrop-blur hover:brightness-110 active:scale-[0.99]">&lt;</button>
    </main>
  </div>

  <!-- Danmaku overlay -->
  <div id="danmaku" class="fixed inset-0 pointer-events-none z-[51] hidden"></div>

  <!-- Confetti canvas (game over) -->
  <canvas id="confetti" class="confetti hidden"></canvas>

  <!-- Game Over Modal -->
  <div id="gameOverModal" class="hidden fixed inset-0 z-[75]">
    <div class="absolute inset-0 backdrop z-0 pointer-events-none" id="gameOverBackdrop"></div>
    <div class="absolute inset-x-0 bottom-0 sm:inset-0 sm:flex sm:items-center sm:justify-center p-3 z-10 pointer-events-auto">
      <div class="w-full sm:max-w-2xl rounded-2xl panel border border-amber-200/20 modal-in">
        <div class="p-4 border-b border-white/10 flex items-start justify-between gap-3">
          <div>
            <div class="text-xs text-emerald-100/70">遊戲完結</div>
            <div class="mt-1 text-lg font-black tracking-tight">總結｜<span id="gameOverRoom" class="mono">—</span></div>
            <div class="mt-1 text-xs text-emerald-100/70">你可以選擇再來一局（重新從第 1 局開始）或離開房間。</div>
          </div>
          <button id="btnCloseGameOver" class="text-xs px-3 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">關閉</button>
        </div>

        <div class="p-4 grid gap-3 max-h-[70vh] overflow-auto">
          <section class="rounded-2xl bg-black/20 border border-white/10 p-3">
            <div class="flex items-center justify-between gap-2">
              <div class="font-semibold">最終排行榜</div>
              <div class="text-xs text-emerald-100/70">依累計分數排序</div>
            </div>
            <div class="mt-2 overflow-auto">
              <table class="w-full text-sm">
                <thead class="text-emerald-100/80">
                  <tr class="border-b border-white/10">
                    <th class="text-left py-2">玩家</th>
                    <th class="text-left py-2">累計</th>
                  </tr>
                </thead>
                <tbody id="gameOverBody"></tbody>
              </table>
            </div>
          </section>
        </div>

        <div class="p-4 border-t border-white/10 flex flex-wrap items-center justify-between gap-2">
          <div class="text-xs text-emerald-100/70">房主按「再來一局」會立即重開；玩家按「再來一局」會向房主提出請求。</div>
          <div class="flex items-center gap-2">
            <button id="btnRestart" class="px-4 py-2 rounded-xl bg-gradient-to-b from-amber-400 to-amber-500 text-slate-950 font-black hover:brightness-105 glow-pulse">再來一局</button>
            <button id="btnExitRoom" class="px-4 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/10">離開房間</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Status Modal (Ready + Score summary) -->
  <div id="statusModal" class="hidden fixed inset-0 z-[52]">
    <div class="absolute inset-0 backdrop" id="statusBackdrop"></div>
    <div class="absolute inset-x-0 bottom-0 sm:inset-0 sm:flex sm:items-center sm:justify-center p-3">
      <div class="w-full sm:max-w-3xl rounded-2xl panel border border-amber-200/20 modal-in">
        <div class="p-4 border-b border-white/10 flex items-start justify-between gap-3">
          <div>
            <div class="text-xs text-emerald-100/70">本局狀態 / 結果（摘要）</div>
            <div class="mt-1 text-lg font-black tracking-tight">狀態｜第 <span id="statusRound" class="mono">—</span> 局</div>
            <div class="mt-1 text-xs text-emerald-100/70">提示：完整牌組請用「查看本局結算」。</div>
          </div>
          <div class="flex items-center gap-2">
            <button id="btnReveal" class="hidden text-xs px-3 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">立即結算（房主）</button>
            <button id="btnNextRound" class="hidden text-xs px-3 py-2 rounded-lg bg-gradient-to-b from-emerald-400 to-emerald-500 text-emerald-950 font-semibold hover:brightness-105">下一局（房主）</button>
            <button id="btnCloseStatus" class="text-xs px-3 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">關閉</button>
          </div>
        </div>
        <div class="p-4 grid gap-3 max-h-[70vh] overflow-auto">
          <section class="rounded-2xl bg-black/20 border border-white/10 p-3">
            <div class="text-sm text-slate-100">玩家提交狀態</div>
            <div id="readyList" class="mt-2 grid gap-2"></div>
          </section>
          <section class="rounded-2xl bg-black/20 border border-white/10 p-3">
            <div class="text-sm text-slate-100">結果表（對莊家）</div>
            <div class="mt-2 overflow-auto">
              <table class="w-full text-sm">
                <thead class="text-emerald-100/80">
                  <tr class="border-b border-white/10">
                    <th class="text-left py-2">玩家</th>
                    <th class="text-left py-2">選莊</th>
                    <th class="text-left py-2">頭</th>
                    <th class="text-left py-2">中</th>
                    <th class="text-left py-2">尾</th>
                    <th class="text-left py-2">報到</th>
                    <th class="text-left py-2">本局</th>
                    <th class="text-left py-2">累計</th>
                    <th class="text-left py-2">備註</th>
                  </tr>
                </thead>
                <tbody id="scoreBody" class="text-slate-50"></tbody>
              </table>
            </div>
            <p class="mt-2 text-xs text-emerald-100/70">完整牌組與牌型請看「結算彈窗」。</p>
          </section>
        </div>
      </div>
    </div>
  </div>

  <!-- Report Modal -->
  <div id="reportModal" class="hidden fixed inset-0 z-[52]">
    <div class="absolute inset-0 backdrop" id="reportBackdrop"></div>
    <div class="absolute inset-x-0 bottom-0 sm:inset-0 sm:flex sm:items-center sm:justify-center p-3">
      <div class="w-full sm:max-w-xl rounded-2xl panel border border-amber-200/20 modal-in">
        <div class="p-4 border-b border-white/10 flex items-start justify-between gap-3">
          <div>
            <div class="text-xs text-emerald-100/70">報到（可選）</div>
            <div class="mt-1 text-lg font-black tracking-tight">本局報到</div>
            <div class="mt-1 text-xs text-emerald-100/70">選擇報到後提交；房主會驗證符合才加分（不符會標註「報到不符」）。報到者本局只計算報到分數。</div>
          </div>
          <button id="btnCloseReport" class="text-xs px-3 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">關閉</button>
        </div>
        <div class="p-4 grid gap-2">
          <div class="text-xs text-emerald-100/70">已改為在「排牌 / 提交」視窗內選擇報到。</div>
        </div>
        <div class="p-4 border-t border-white/10 flex items-center justify-between gap-2">
          <div class="text-xs text-emerald-100/70">報到只在你提交時一起送出。</div>
          <button id="btnCloseReport2" class="text-xs px-3 py-2 rounded-lg bg-gradient-to-b from-amber-400 to-amber-500 text-slate-950 font-semibold hover:brightness-105">好</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Dealer Pick (Pre-Reveal) Modal: after all submitted, before reveal -->
  <div id="dealerPickPreModal" class="hidden fixed inset-0 z-[54]">
    <div class="absolute inset-0 backdrop" id="dealerPickPreBackdrop"></div>
    <div class="absolute inset-x-0 bottom-0 sm:inset-0 sm:flex sm:items-center sm:justify-center p-3">
      <div class="w-full sm:max-w-2xl rounded-2xl panel border border-amber-200/20 modal-in">
        <div class="p-4 border-b border-white/10 flex items-start justify-between gap-3">
          <div>
            <div class="text-xs text-emerald-100/70">結算前指定莊家</div>
            <div id="dealerPickPreTitle" class="mt-1 text-lg font-black tracking-tight">—</div>
            <div id="dealerPickPreDesc" class="mt-1 text-xs text-emerald-100/70">—</div>
          </div>
          <button id="btnCloseDealerPickPre" class="text-xs px-3 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">關閉</button>
        </div>

        <div class="p-4 grid gap-3 max-h-[70vh] overflow-auto">
          <section class="rounded-2xl bg-black/20 border border-white/10 p-3">
            <div class="flex items-center justify-between gap-2">
              <div class="font-semibold">請選擇莊家</div>
              <div class="text-xs text-emerald-100/70">同時顯示各玩家選莊牌</div>
            </div>
            <div id="dealerPickPreList" class="mt-2 grid gap-2"></div>
          </section>
        </div>

        <div class="p-4 border-t border-white/10 flex items-center justify-between gap-2">
          <div class="text-xs text-emerald-100/70">提示：若有大鬼，本局由大鬼玩家決定；否則由細鬼玩家決定。</div>
          <button id="btnDealerPickPreConfirm" class="text-xs px-3 py-2 rounded-lg bg-gradient-to-b from-amber-400 to-amber-500 text-slate-950 font-semibold hover:brightness-105">確定</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Chat Modal (repurposed from Log) -->
  <div id="logModal" class="hidden fixed inset-0 z-[52]">
    <div class="absolute inset-0 backdrop" id="logBackdrop"></div>
    <div class="absolute inset-x-0 bottom-0 sm:inset-0 sm:flex sm:items-center sm:justify-center p-3">
      <div class="w-full sm:max-w-2xl rounded-2xl panel border border-amber-200/20 modal-in">
        <div class="p-4 border-b border-white/10 flex items-start justify-between gap-3">
          <div>
            <div class="text-xs text-emerald-100/70">聊天室</div>
            <div class="mt-1 text-lg font-black tracking-tight">Chat</div>
            <div class="mt-1 text-[11px] text-emerald-100/70">提示：有新訊息時，底部「聊天」會閃爍。</div>
          </div>
          <div class="flex items-center gap-2">
            <button id="btnClearGameLog" class="text-xs px-3 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">清空</button>
            <button id="btnCloseLog" class="text-xs px-3 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">關閉</button>
          </div>
        </div>

        <div class="p-4 grid gap-3 max-h-[70vh] overflow-auto">
          <section class="rounded-2xl bg-black/20 border border-white/10 p-3">
            <div class="text-xs text-emerald-100/70">訊息</div>
            <div id="gameLog" class="mt-2 text-xs text-emerald-50/90 space-y-1 max-h-[42vh] overflow-auto pr-1"></div>
          </section>

          <section class="rounded-2xl bg-black/20 border border-white/10 p-3">
            <div class="text-xs text-emerald-100/70">快捷句</div>
            <div id="chatQuick" class="mt-2 flex flex-wrap gap-2">
              <button type="button" data-msg="屌你老母又Pair煙" class="text-[11px] px-2.5 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/10">屌你老母又Pair煙</button>
              <button type="button" data-msg="師傅你真係好撚正" class="text-[11px] px-2.5 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/10">師傅你真係好撚正</button>
              <button type="button" data-msg="贏撚完未呀" class="text-[11px] px-2.5 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/10">贏撚完未呀</button>
              <button type="button" data-msg="幾撚時死呀?" class="text-[11px] px-2.5 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/10">幾撚時死呀?</button>
              <button type="button" data-msg="執幾撚耐呀" class="text-[11px] px-2.5 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/10">執幾撚耐呀</button>
            </div>
          </section>

          <section class="rounded-2xl bg-black/20 border border-white/10 p-3">
            <div class="text-xs text-emerald-100/70">Sticker</div>
            <div id="stickerStatus" class="mt-1 text-[11px] text-emerald-100/70">載入中…</div>
            <div id="chatStickers" class="mt-2 grid grid-cols-5 sm:grid-cols-6 gap-2"></div>
          </section>

          <details id="debugPanel" class="rounded-2xl bg-black/20 border border-white/10 p-3 hidden">
            <summary class="cursor-pointer select-none text-xs text-emerald-100/70">DEBUG（Drive Icon Lookup）</summary>
            <div class="mt-2 text-[10px] text-emerald-100/60">預設關閉。啟用：localStorage.setItem('ninePokerDebug','1') 後重載。只顯示本機 icon 查詢/載入狀態，不會廣播。</div>
            <div id="chatDebug" class="mt-2 text-[11px] text-emerald-100/70 space-y-1 max-h-32 overflow-auto pr-1"></div>
          </details>

          <section class="rounded-2xl bg-black/20 border border-white/10 p-3">
            <div class="text-xs text-emerald-100/70">輸入</div>
            <div class="mt-2 flex items-center gap-2">
              <input id="inpChat" maxlength="200" class="flex-1 bg-black/35 border border-white/10 rounded-xl px-3 py-2 outline-none focus:border-amber-200/50" placeholder="輸入訊息…（Enter 發送）" />
              <button id="btnSendChat" class="shrink-0 text-xs px-3 py-2 rounded-xl bg-gradient-to-b from-sky-400 to-sky-500 text-sky-950 font-semibold hover:brightness-105">發送</button>
            </div>
          </section>
        </div>
      </div>
    </div>
  </div>

  <!-- Arrange Modal (your hand arrangement) -->
<div id="arrangeModal" class="hidden fixed inset-0 z-[53]">
    <div class="absolute inset-0 backdrop" id="arrangeBackdrop"></div>
    
    <div class="absolute inset-0 z-10 flex items-center justify-center pointer-events-none">
      
      <div class="pointer-events-auto relative flex flex-row items-center justify-center gap-4 sm:gap-10 p-4 w-full max-w-5xl h-full max-h-[85vh]">
         
         <div class="absolute top-0 left-4 z-30 flex flex-col items-start shadow-black drop-shadow-md">
            <div class="text-[10px] text-emerald-100/60">排牌階段</div>
            <div id="arrangeTimerText" class="text-xl font-bold text-emerald-100 mono">--</div>
         </div>

         <button id="btnCloseArrange" class="absolute top-0 right-2 z-30 w-10 h-10 rounded-full bg-rose-500/20 hover:bg-rose-500/30 border border-rose-500/30 text-rose-100 flex items-center justify-center active:scale-95 transition backdrop-blur-md shadow-lg">
            ✕
         </button>

         <div class="flex flex-col justify-center gap-6 select-none h-full w-auto">
             
             <div class="flex items-center gap-2 justify-end">
                <span id="headEval" class="text-[10px] font-bold text-emerald-200/80 w-12 text-right tabular-nums tracking-tighter">—</span>
                
                <div class="flex flex-col items-center justify-center text-[10px] font-bold text-emerald-100/50 leading-none gap-0.5">
                    <span>頭</span><span>墩</span>
                </div>
                <div id="slotHead" class="grid grid-cols-2 gap-1.5"></div>
                <div class="w-[50px] sm:w-[58px]"></div> 
             </div>

             <div class="flex items-center gap-2 justify-end">
                <span id="midEval" class="text-[10px] font-bold text-emerald-200/80 w-12 text-right tabular-nums tracking-tighter">—</span>

                <div class="flex flex-col items-center justify-center text-[10px] font-bold text-emerald-100/50 leading-none gap-0.5">
                    <span>中</span><span>墩</span>
                </div>
                <div id="slotMid" class="grid grid-cols-3 gap-1.5"></div>
             </div>

             <div class="flex items-center gap-2 justify-end">
                 <span id="tailEval" class="text-[10px] font-bold text-emerald-200/80 w-12 text-right tabular-nums tracking-tighter">—</span>

                 <div class="flex flex-col items-center justify-center text-[10px] font-bold text-emerald-100/50 leading-none gap-0.5">
                    <span>尾</span><span>墩</span>
                </div>
                <div id="slotTail" class="grid grid-cols-3 gap-1.5"></div>
             </div>
          </div>
            
         <div class="flex flex-col w-32 shrink-0 gap-3 justify-center">
             
             <div class="flex flex-col items-center gap-1 p-2 rounded-xl bg-white/5 border border-white/5">
                <div class="text-[10px] text-amber-100/60 font-bold">選莊</div>
                <div id="dealerCardSlot" class="shrink-0 shadow-[0_0_20px_rgba(251,191,36,0.15)]"></div>
             </div>

             <div class="p-2 rounded-xl bg-white/5 border border-white/5 flex flex-col gap-2">
                <div class="flex justify-between items-end">
                    <label class="text-[10px] text-emerald-100/40">報到</label>
                    <span id="submitStatus2" class="text-[10px] text-emerald-100/80 scale-90 origin-right">—</span>
                </div>
                <select id="selReport" class="bg-slate-950 border border-white/20 rounded-lg px-1 py-1.5 text-xs text-slate-100 outline-none w-full text-center font-bold">
                    <option value="none">無 (不報到)</option>
                    <option value="allRed">全紅 +5</option>
                    <option value="allBlack">全黑 +5</option>
                    <option value="threeSnake">三蛇 +3</option>
                    <option value="fourKind">4條 +10</option>
                    <option value="fourPairs">4對 +10</option>
                    <option value="mixedDragon">雜龍 +15</option>
                    <option value="threeStraightFlush">3同花順 +25</option>
                    <option value="twoFourKind">2個4條 +30</option>
                    <option value="greenDragon">青龍 +100</option>
                    <option value="noHand">百無 +3</option>
                </select>
                <button id="btnSubmit" class="w-full py-2.5 rounded-xl bg-gradient-to-r from-amber-400 to-amber-600 text-black font-black text-sm shadow-lg hover:brightness-110 active:scale-95 transition-transform">
                  提交
                </button>
             </div>
            
             <div class="grid grid-cols-2 gap-2">
                <button id="btnAutoFill" class="col-span-1 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10 text-slate-200 text-xs font-bold active:scale-95 transition">快速</button>
                <button id="btnResetArrange" class="col-span-1 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10 text-slate-200 text-xs font-bold active:scale-95 transition">重排</button>
             </div>


         </div>

      </div>
    </div>
</div>

  <!-- Scoreboard Modal (DAY / MON) -->
  <div id="scoreboardModal" class="hidden fixed inset-0 z-[52]">
    <div class="absolute inset-0 backdrop" id="scoreboardBackdrop"></div>
    <div class="absolute inset-x-0 bottom-0 sm:inset-0 sm:flex sm:items-center sm:justify-center p-3">
      <div class="w-full sm:max-w-2xl rounded-2xl panel border border-amber-200/20 modal-in">
        <div class="p-4 border-b border-white/10 flex items-start justify-between gap-3">
          <div>
            <div class="text-xs text-emerald-100/70">計分版</div>
            <div class="mt-1 text-lg font-black tracking-tight">DAY / MONTH</div>
            <div class="mt-1 text-xs text-emerald-100/70">資料來源：GitHub records/DAY.json、records/MON.json（只顯示累計）</div>
          </div>
          <div class="flex items-center gap-2">
            <button id="btnScoreboardRefresh" class="text-xs px-3 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">重新載入</button>
            <button id="btnCloseScoreboard" class="text-xs px-3 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">關閉</button>
          </div>
        </div>

        <div class="p-4 grid gap-3 max-h-[70vh] overflow-auto">
          <div class="flex items-center gap-2">
            <button id="btnTabNig" type="button" class="text-xs px-3 py-2 rounded-xl border border-white/10 bg-white/10 hover:bg-white/15 text-emerald-50 font-black">MON</button>
            <div id="scoreboardStatus" class="ml-auto text-[11px] text-emerald-100/70">—</div>
          </div>

          <section class="rounded-2xl bg-black/20 border border-white/10 p-3">
            <div class="flex items-center justify-between gap-2">
              <div class="font-semibold">排行榜</div>
              <div class="text-xs text-emerald-100/70">依累計分數排序</div>
            </div>
            <div class="mt-2 overflow-auto">
              <table class="w-full text-sm">
                <thead class="text-emerald-100/80">
                  <tr class="border-b border-white/10">
                    <th class="text-left py-2">排名</th>
                    <th class="text-left py-2">玩家</th>
                    <th class="text-left py-2">累計</th>
                  </tr>
                </thead>
                <tbody id="scoreboardBody"></tbody>
              </table>
            </div>
          </section>
        </div>
      </div>
    </div>
  </div>

  <!-- Reveal Modal -->
  <div id="revealModal" class="hidden fixed inset-0 z-[60]">
    <div class="absolute inset-0 backdrop" id="revealBackdrop"></div>
    <div class="absolute inset-x-0 bottom-0 sm:inset-0 sm:flex sm:items-center sm:justify-center p-2">
      <div class="w-full sm:max-w-5xl rounded-2xl panel border border-amber-200/20">
        <div class="p-4 border-b border-white/10 flex items-start justify-between gap-3">
          <div>
            <div class="text-xs text-emerald-100/70">本局結算</div>
            <div class="mt-1 text-lg font-black tracking-tight">
              第 <span id="revealRound" class="mono">—</span> 局｜莊家：<span id="revealDealer" class="font-black">—</span>
            </div>
            <div class="mt-1 text-xs text-emerald-100/70">提示：頭墩對子以點數計分；中墩同花順+10/三條+6；尾墩同花順+5/三條+3。擺烏龍/報到不符會在結算時處理。</div>
          </div>
          <div class="flex items-center gap-2">
            <button id="btnCloseReveal" class="text-xs px-3 py-2 rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">關閉</button>
          </div>
        </div>

        <div class="p-3 sm:p-4 grid gap-2 max-h-[64vh] overflow-auto">
          <section class="rounded-2xl bg-black/20 border border-white/10 p-3">
            <div class="flex items-center justify-between gap-2">
              <div class="font-semibold">分數總覽</div>
              <div class="text-xs text-emerald-100/70">本局 vs 莊家（莊家為淨值）</div>
            </div>
            <div class="mt-2 overflow-auto max-h-[34vh]">
              <table class="w-full text-sm">
                <thead class="text-emerald-100/80">
                  <tr class="border-b border-white/10">
                    <th class="text-left py-2">玩家</th>
                    <th class="text-left py-2">選莊</th>
                    <th class="text-left py-2">頭</th>
                    <th class="text-left py-2">中</th>
                    <th class="text-left py-2">尾</th>
                    <th class="text-left py-2">報到</th>
                    <th class="text-left py-2">本局</th>
                    <th class="text-left py-2">累計</th>
                    <th class="text-left py-2">備註</th>
                  </tr>
                </thead>
                <tbody id="revealScoreBody"></tbody>
              </table>
            </div>
          </section>

          <details class="rounded-2xl bg-black/20 border border-white/10 p-3">
            <summary class="cursor-pointer select-none flex items-center justify-between gap-2">
              <div class="font-semibold">每位玩家牌組（點此展開）</div>
              <div class="text-xs text-emerald-100/70">選莊牌 + 頭/中/尾 + 報到</div>
            </summary>
            <div id="revealHands" class="mt-3 grid gap-2"></div>
          </details>
        </div>

        <div class="p-4 border-t border-white/10 flex items-center justify-between gap-2">
          <div class="text-xs text-emerald-100/70">可按右上角關閉；房主可在主畫面按「下一局」。</div>
          <button id="btnCloseReveal2" class="text-xs px-3 py-2 rounded-lg bg-gradient-to-b from-amber-400 to-amber-500 text-slate-950 font-semibold hover:brightness-105">好</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden compatibility nodes (kiosk UI removed but JS still expects these ids) -->
  <div class="hidden">
    <div id="gameRoleBadge"></div>
    <div id="gameRoomId"></div>
    <div id="gameRoundInfo"></div>
    <div id="dealerName"></div>
    <span id="myCumulative">0</span>
    <button id="btnOpenLastReveal" type="button"></button>
    <button id="btnOpenArrange" type="button"></button>
    <button id="btnBackToLobby" type="button"></button>
    <input id="inpCustomRoomId" />
  </div>

  <script>
    /**
     * HKE九張 原型：
     * - P2P（PeerJS）
     * - 房主作為權威：玩家列表、局數、發牌、結算。
     * - 每局每人 9 張：玩家自由選 1 張作「選莊牌」，剩下 8 張排成：頭 2 / 中 3 / 尾 3。
     * - 大鬼細鬼（JOKER）作百搭，結算以 2 張（頭）/ 3 張（中尾）牌型（簡化）比較。
     * - 擺烏龍：頭 > 中 或 中 > 尾（允許提交；結算時按規則處理）。
     * - 結算用彈窗顯示詳細牌組；並提供跨回合累計分數。
     */

    // -------------------- UI helpers --------------------
    // Build/version stamp (used for update check)
    const APP_BUILD = '2026-01-07-1';
    let swReg = null;
    let updateCheckTimer = null;

    // ==========================================
    // HKE九張 專用拖曳邏輯
    // ==========================================
    let dragGhost = null;
    let isDragging = false;
    let dragSrcRef = null; // 來源: {zone, key} 或 {zone, slot, idx}

    function handleDragStart(e, ref) {
      if (clientState.submitted) return;
      // 已提交不可拖動
      if (e.type === 'mousedown' && e.button !== 0) return;
      // 只允許左鍵

      const touch = e.touches ? e.touches[0] : e;
      dragSrcRef = ref;
      // 建立視覺替身 (Ghost)
      const target = e.currentTarget;
      dragGhost = target.cloneNode(true);
      dragGhost.style.position = 'fixed';
      dragGhost.style.zIndex = '9999';
      dragGhost.style.pointerEvents = 'none'; // 讓事件穿透
      dragGhost.style.opacity = '0.85';
      dragGhost.style.transform = 'scale(1.05) rotate(3deg)';
      dragGhost.style.boxShadow = '0 10px 20px rgba(0,0,0,0.3)';
      
      // 初始位置
      const w = target.offsetWidth;
      const h = target.offsetHeight;
      dragGhost.style.width = w + 'px';
      dragGhost.style.height = h + 'px';
      dragGhost.style.left = (touch.clientX - w/2) + 'px';
      dragGhost.style.top = (touch.clientY - h/2) + 'px';

      document.body.appendChild(dragGhost);
      isDragging = true;
      // 綁定全域移動事件
      if (e.type === 'touchstart') {
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('touchend', handleDragEnd);
      } else {
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', handleDragEnd);
      }
      
    const dock = document.getElementById('handDock');
      if (dock) {
         dock.style.visibility = 'hidden';
      }
    }

    function handleDragMove(e) {
      if (!isDragging || !dragGhost) return;
      if (e.cancelable) e.preventDefault(); // 防止手機滾動

      const touch = e.touches ? e.touches[0] : e;
      const w = parseFloat(dragGhost.style.width);
      const h = parseFloat(dragGhost.style.height);
      dragGhost.style.left = (touch.clientX - w/2) + 'px';
      dragGhost.style.top = (touch.clientY - h/2) + 'px';
    }

    function handleDragEnd(e) {
      
      // 注意：這裡不要急著把 dock 顯示回來，
      // 必須先執行 elementFromPoint，否則 dock 會再次擋住視線
      
      if (!isDragging) {
         // 如果沒有在拖曳（只是點擊），也要確保 dock 是可見的
         const dock = document.getElementById('handDock');
         if (dock) dock.style.visibility = '';
         return;
      }
      
      isDragging = false;
      if (dragGhost) {
        dragGhost.remove();
        dragGhost = null;
      }

      document.removeEventListener('touchmove', handleDragMove);
      document.removeEventListener('touchend', handleDragEnd);
      document.removeEventListener('mousemove', handleDragMove);
      document.removeEventListener('mouseup', handleDragEnd);

      const touch = e.changedTouches ? e.changedTouches[0] : e;
      
      // 因為 dock 還是 hidden 狀態，這裡一定能穿透抓到底下的 Slot
      const targetElem = document.elementFromPoint(touch.clientX, touch.clientY);
      const dropTarget = targetElem ? targetElem.closest('[data-drop-zone]') : null;

      if (dropTarget && dragSrcRef) {
        const zone = dropTarget.dataset.zone;
        let destRef = null;

        if (zone === 'hand') {
            const cardTarget = targetElem.closest('[data-key]');
            if (cardTarget) {
                destRef = { zone: 'hand', key: cardTarget.dataset.key };
            } else {
                 destRef = { zone: 'hand', key: dragSrcRef.key };
            }
        } else if (zone === 'dealer') {
            destRef = { zone: 'dealer' };
        } else if (zone === 'slot') {
            destRef = { 
                zone: 'slot', 
                slot: dropTarget.dataset.slot, 
                idx: parseInt(dropTarget.dataset.idx) 
            };
        }

        if (destRef) {
            applySwapOrMove(dragSrcRef, destRef);
            clearPick();
            renderGameHeader();
            renderHand();
            renderSlots();
        }
      }
      dragSrcRef = null;

      // 【關鍵修改】判定完成後，才把 HandDock 顯示回來
      const dock = document.getElementById('handDock');
      if (dock) {
         dock.style.visibility = '';
         
         // 確保裡面的手牌位置重置（防止動畫殘留）
         const handEl = document.getElementById('hand');
         if (handEl) {
             handEl.classList.remove('translate-y-[150%]', 'opacity-0');
         }
      }
    }
    
    // 【新增】統一取得「名字+房主+分數」的字串
    function getFormattedName(p) {
      // 1. 處理基本名稱
      let base = p.name || '無名氏';
  
      // 2. 處理房主標記
      if (p.isHost) {
        base += '（房主）';
      }

      // 3. 處理分數 (讀取 clientState.cumulative)
      const currentScore = (clientState.cumulative && clientState.cumulative[p.id]) || 0;
      const scoreText = currentScore > 0 ? `+${currentScore}` : `${currentScore}`;

      return `${base} ${scoreText}`;
    }
    
    function isLobbyVisible() {
      const lobby = $('pageLobby');
      return lobby && !lobby.classList.contains('hidden');
    }

    function setUpdateAvailable(available, info='') {
      clientState.updateAvailable = !!available;
      const btn = $('btnUpdateApp');
      if (!btn) return;
      const show = !!available && isLobbyVisible();
      //btn.classList.toggle('hidden', !show);
      btn.classList.toggle('update-available', !!available);
      btn.title = available ? (info || '有新版本可更新') : '';
    }

    async function clearAllCachesBestEffort() {
      try {
        if (!('caches' in window)) return;
        const keys = await caches.keys();
        await Promise.all(keys.map(k => caches.delete(k)));
      } catch {}
    }

    async function applyAppUpdate() {
      try { await toast('更新中…'); } catch {}

      // Prefer SW update flow
      try {
        if (swReg) {
          try { await swReg.update(); } catch {}
          if (swReg.waiting) {
            try {
              swReg.waiting.postMessage({ type: 'SKIP_WAITING' });
            } catch {}
            // Reload when new SW takes control
            return;
          }
        }
      } catch {}

      // Fallback: clear caches and reload
      await clearAllCachesBestEffort();
      location.reload();
    }

    async function checkVersionOnce() {
      // Lightweight version file check; no-store + bust param bypasses SW cache.
      try {
        const res = await fetch('./version.json?bust=' + Date.now(), { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        const remote = String(json?.build || '').trim();
        if (remote && remote !== APP_BUILD) {
          setUpdateAvailable(true, `發現新版本：${remote}`);
        }
      } catch {}
    }

    function startVersionPolling() {
      if (updateCheckTimer) return;
      updateCheckTimer = setInterval(() => {
        if (!isLobbyVisible()) return;
        if (clientState.updateAvailable) return;
        checkVersionOnce();
        try { swReg?.update(); } catch {}
      }, 30000);
    }

    function stopVersionPolling() {
      if (updateCheckTimer) {
        clearInterval(updateCheckTimer);
        updateCheckTimer = null;
      }
    }

    const $ = (id) => document.getElementById(id);
    const el = (tag, cls, txt) => {
      const n = document.createElement(tag);
      if (cls) n.className = cls;
      if (txt !== undefined) n.textContent = txt;
      return n;
    };
    const nowTime = () => new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
    const log = (msg) => {
      const line = el('div', 'text-emerald-50/80', `[${nowTime()}] ${msg}`);
      $('log').prepend(line);
    };

    // Debug toggle (local-only). Enable via:
    // localStorage.setItem('ninePokerDebug','1'); location.reload();
    // Disable via:
    //   localStorage.removeItem('ninePokerDebug'); location.reload();
    const DEBUG_ENABLED = (localStorage.getItem('ninePokerDebug') === '1');

    // Debug log (local-only) shown inside Chat modal
    const dlog = (msg) => {
      if (!DEBUG_ENABLED) return;
      const box = $('chatDebug');
      if (!box) return;
      const line = el('div', 'text-emerald-100/70', `[${nowTime()}] ${msg}`);
      box.prepend(line);
    };
    // Chat log: only keep real chat messages (system/game info should not be here)
    const glog = (msg, opts={}) => {
      if (!opts?.chat) return; // hide game/system info in chat

      const line = el('div', 'text-emerald-50/90');
      const time = `[${nowTime()}] `;

      if (opts.kind === 'sticker' && opts.url) {
        const row = el('div', 'flex items-start gap-2');
        row.appendChild(el('div', 'shrink-0 text-emerald-50/90', time + (msg || '')));
        const img = document.createElement('img');
        img.src = opts.url;
        img.alt = 'sticker';
        img.className = 'chat-sticker';
        row.appendChild(img);
        line.appendChild(row);
      } else {
        line.textContent = time + String(msg || '');
      }

      $('gameLog').prepend(line);

      const chatOpen = !$('logModal').classList.contains('hidden');
      if (!chatOpen) {
        clientState.chatUnread = true;
        updateChatUnread();
      }
    };
    const toast = async (msg) => {
      const t = el('div', 'fixed bottom-4 left-1/2 -translate-x-1/2 z-[60] px-3 py-2 rounded-xl bg-black/70 border border-amber-200/20 text-xs text-amber-50 shadow-lg backdrop-blur', msg);
      document.body.appendChild(t);
      await new Promise(r => setTimeout(r, 1700));
      t.remove();
    };
    const setBadge = (online, text) => {
      $('netBadge').textContent = text;
      $('netBadge').className = 'text-xs px-2 py-1 rounded-full chip ' + (online
        ? 'text-emerald-50 border-emerald-300/30 bg-emerald-500/15'
        : 'text-amber-100 border-amber-300/25 bg-amber-300/10');
    };

    // -------------------- Player icon (by name) --------------------
    // Preferred icon source: Google Drive folder
    // Folder: https://drive.google.com/drive/folders/1wXFqri-r7MjatMM8qwaQWCY3zGsFUiKx
    // IMPORTANT: Google Drive cannot be accessed by filename path directly (no /<name>.png URLs).
    // To load <name>.png from a Drive folder, we must resolve the fileId via Google Drive API.
    // This app supports:
    // - Drive API resolve (if you provide DRIVE_API_KEY)
    // - Fallback to GitHub/jsDelivr (so icons still work without a key)

    const DRIVE_FOLDER_ID = '1wXFqri-r7MjatMM8qwaQWCY3zGsFUiKx';
    const DRIVE_API_KEY = 'AIzaSyDvioGAwurZtmD-rWV3bIyWv60UtanMimI'; // optional: put your Google API key here to enable Drive lookup

    const ICON_FALLBACK_BASE = 'https://cdn.jsdelivr.net/gh/hketerrell/HKE9@main/icon/';

    const iconCache = new Map(); // name -> 'ok' | 'fail'
    let driveIconIndex = null; // name -> fileId
    const driveDbgSeen = new Set(); // name -> logged

    function loadDriveIconIndex() {
      if (driveIconIndex) return driveIconIndex;
      try {
        const raw = localStorage.getItem('ninePokerDriveIconIndex');
        driveIconIndex = raw ? (JSON.parse(raw) || {}) : {};
      } catch {
        driveIconIndex = {};
      }
      return driveIconIndex;
    }

    function saveDriveIconIndex() {
      try { localStorage.setItem('ninePokerDriveIconIndex', JSON.stringify(driveIconIndex || {})); } catch {}
    }

    function driveIconUrls(fileId) {
      const id = encodeURIComponent(fileId);
      // Try multiple public patterns. Different Drive setups may allow different endpoints.
      // Note: some endpoints may redirect or require cookies; we try several and only use one that truly loads.
      return [
        // Modern googleusercontent patterns
        `https://lh3.googleusercontent.com/d/${id}=w200-h200`,
        `https://lh3.googleusercontent.com/u/0/d/${id}=w200-h200`,
        // Thumbnail endpoint (often works even when uc fails)
        `https://drive.google.com/thumbnail?id=${id}&sz=w200`,
        // Legacy uc endpoints
        `https://drive.google.com/uc?export=view&id=${id}`,
        `https://drive.google.com/uc?id=${id}`,
        `https://drive.google.com/uc?export=download&id=${id}`,
      ];
    }

    function driveIconUrl(fileId) {
      return driveIconUrls(fileId)[0];
    }

    async function resolveDriveFileIdByName(name) {
      const n = String(name || '').trim();
      if (!n) return null;
      if (!DRIVE_API_KEY) {
        if (!driveDbgSeen.has(n)) {
          driveDbgSeen.add(n);
          dlog(`Drive icon: skipped (no API key) for ${n}`);
        }
        return null;
      }

      const idx = loadDriveIconIndex();
      if (idx[n]) {
        if (!driveDbgSeen.has(n)) {
          driveDbgSeen.add(n);
          dlog(`Drive icon: cache hit for ${n} => ${idx[n]}`);
        }
        return idx[n];
      }

      if (!driveDbgSeen.has(n)) {
        driveDbgSeen.add(n);
        dlog(`Drive icon: lookup start for ${n}`);
      }

      // Escape single quotes for Drive query
      const safeBase = n.replace(/'/g, "\\'");
      const candidates = [`${safeBase}.png`, `${safeBase}.PNG`, `${safeBase}.Png`];

      for (const fileName of candidates) {
        const q = `'${DRIVE_FOLDER_ID}' in parents and trashed=false and name='${fileName}'`;
        const url = `https://www.googleapis.com/drive/v3/files?` +
          `q=${encodeURIComponent(q)}` +
          `&fields=${encodeURIComponent('files(id,name)')}` +
          `&pageSize=1` +
          `&supportsAllDrives=true&includeItemsFromAllDrives=true` +
          `&key=${encodeURIComponent(DRIVE_API_KEY)}`;

        let res;
        try {
          res = await fetch(url, { cache: 'no-store' });
        } catch (e) {
          dlog(`Drive icon: fetch error for ${n} (${fileName}): ${e?.message || e}`);
          continue;
        }

        if (!res.ok) {
          try {
            const txt = await res.text();
            dlog(`Drive icon: lookup failed (${res.status}) for ${n} (${fileName}): ${txt?.slice(0,160)}`);
          } catch {
            dlog(`Drive icon: lookup failed (${res.status}) for ${n} (${fileName})`);
          }
          continue;
        }

        let json = null;
        try {
          json = await res.json();
        } catch (e) {
          dlog(`Drive icon: JSON parse error for ${n} (${fileName})`);
          continue;
        }

        const id = json?.files?.[0]?.id || null;
        if (id) {
          idx[n] = id;
          driveIconIndex = idx;
          saveDriveIconIndex();
          dlog(`Drive icon: found for ${n} => ${id}`);
          return id;
        }
      }

      dlog(`Drive icon: not found for ${n} (no matching png in folder)`);
      return null;
    }

    function iconUrlForName(name) {
      const n = String(name || '').trim();
      if (!n) return '';
      const idx = loadDriveIconIndex();
      if (idx[n]) return driveIconUrl(idx[n]);
      // fallback (used when no Drive API key / not resolved yet)
      return ICON_FALLBACK_BASE + encodeURIComponent(n) + '.png';
    }

    function createPlayerIconNode(name) {
      const n = String(name || '').trim();
      if (!n) return null;

      const wrap = el('div', 'w-9 h-9 sm:w-10 sm:h-10 rounded-full bg-black/20 border border-white/10 flex items-center justify-center overflow-hidden mb-1 mx-auto');
      const img = document.createElement('img');
      img.alt = n;
      img.loading = 'lazy';
      img.decoding = 'async';
      // Some Google image endpoints may fail with no-referrer on certain browsers.
      // Use a more compatible policy.
      img.referrerPolicy = 'origin';
      img.className = 'w-full h-full object-contain p-1';

      const idx = loadDriveIconIndex();
      const cachedDriveId = idx[n] || null;

      let loaded = false;
      let mode = cachedDriveId ? 'drive' : 'fallback';
      let driveTry = { id: cachedDriveId, urls: cachedDriveId ? driveIconUrls(cachedDriveId) : [], i: 0 };

      const fallbackUrl = ICON_FALLBACK_BASE + encodeURIComponent(n) + '.png';

      const setFallback = () => {
        mode = 'fallback';
        img.src = fallbackUrl;
      };

      const tryNextDriveUrl = () => {
        if (!driveTry?.urls?.length) return false;
        if (driveTry.i >= driveTry.urls.length) return false;
        const u = driveTry.urls[driveTry.i++];
        mode = 'drive';
        img.src = u;
        return true;
      };

      const setDrive = (id) => {
        if (!id) return;
        driveTry = { id, urls: driveIconUrls(id), i: 0 };
        mode = 'drive';
        tryNextDriveUrl();

        // watchdog: if drive hangs/blocked, try next URL variant before falling back
        const watchdogOnce = () => {
          if (!wrap.isConnected) return;
          if (loaded) return;
          if (mode !== 'drive') return;

          if (tryNextDriveUrl()) {
            dlog(`Drive icon: image timeout -> try next URL (${driveTry.i}/${driveTry.urls.length}) => ${n}`);
            setTimeout(watchdogOnce, 1800);
            return;
          }

          dlog(`Drive icon: image timeout (all URL variants), fallback => ${n}`);
          dlog(`Drive icon hint: check file permission (Anyone with the link can view) for ${n}.png`);

          // Delete cached id (to avoid repeated failures) and fall back
          try {
            const idx2 = loadDriveIconIndex();
            if (idx2[n]) {
              delete idx2[n];
              driveIconIndex = idx2;
              saveDriveIconIndex();
            }
          } catch {}

          setFallback();
        };

        setTimeout(watchdogOnce, 1800);
      };

      // Start with fallback immediately (so we always show something fast),
      // then upgrade to Drive (preferred) if we can load it.
      setFallback();
      if (cachedDriveId) {
        loaded = false;
        setDrive(cachedDriveId);
      }

      img.addEventListener('load', () => {
        loaded = true;
        iconCache.set(n, 'ok');
        if (!img.__dbgLoaded) {
          img.__dbgLoaded = true;
          dlog(`Icon loaded (${mode}) => ${n}`);
        }
      });

      img.addEventListener('error', async () => {
        if (mode === 'drive') {
          // Try next drive URL variant first
          if (tryNextDriveUrl()) {
            dlog(`Drive icon: retry next URL (${driveTry.i}/${driveTry.urls.length}) => ${n}`);
            return;
          }

          dlog(`Drive icon: image failed (all URL variants), fallback => ${n}`);
          dlog(`Drive icon hint: check file permission (Anyone with the link can view) for ${n}.png`);

          // Delete cached id (to avoid repeated failures) and fall back
          try {
            const idx2 = loadDriveIconIndex();
            if (idx2[n]) {
              delete idx2[n];
              driveIconIndex = idx2;
              saveDriveIconIndex();
            }
          } catch {}

          loaded = false;
          setFallback();
          return;
        }

        // fallback failed too
        dlog(`Icon fallback failed => ${n} (${fallbackUrl})`);
        iconCache.set(n, 'fail');
        // Keep a minimal text placeholder instead of removing the node,
        // so the seat layout stays stable.
        try {
          wrap.innerHTML = '';
          wrap.className = 'w-9 h-9 sm:w-10 sm:h-10 rounded-full bg-black/20 border border-white/10 flex items-center justify-center mb-1 mx-auto';
          const initials = Array.from(n).slice(0,2).join('') || '?';
          wrap.appendChild(el('div','text-[10px] font-black text-amber-100/80 tracking-tight', initials));
        } catch {}
      });

      wrap.appendChild(img);

      // Best-effort: resolve Google Drive fileId and switch to Drive (preferred)
      if (!cachedDriveId && DRIVE_API_KEY) {
        resolveDriveFileIdByName(n).then((id) => {
          if (!id) return;
          if (!wrap.isConnected) return;
          // Upgrade to Drive even if fallback already loaded
          loaded = false;
          setDrive(id);
        }).catch((e) => {
          dlog(`Drive icon: resolve error for ${n}: ${e?.message || e}`);
        });
      }

      return wrap;
    }

    function showPage(which) {
      const lobby = $('pageLobby');
      const game = $('pageGame');
      const goLobby = $('btnGoLobby');
      if (which === 'lobby') {
        lobby.classList.remove('hidden');
        game.classList.add('hidden');
        goLobby.classList.add('hidden');
      } else {
        lobby.classList.add('hidden');
        game.classList.remove('hidden');
        goLobby.classList.remove('hidden');
      }
      // update update button visibility
      try { setUpdateAvailable(!!clientState.updateAvailable); } catch {}
      if (which === 'lobby') startVersionPolling(); else stopVersionPolling();
      updateBodyOverflow();
    }

    function updateBodyOverflow() {
      const ids = ['revealModal','gameOverModal','statusModal','reportModal','logModal','dealerPickPreModal','arrangeModal','scoreboardModal'];
      const anyOpen = ids.some(id => {
        const n = $(id);
        return n && !n.classList.contains('hidden');
      });
      document.body.style.overflow = anyOpen ? 'hidden' : '';

      // Hide "回大廳" while any modal is open to avoid blocking modal buttons
      const goLobby = $('btnGoLobby');
      if (goLobby) {
        const inGame = !$('pageGame').classList.contains('hidden');
        goLobby.classList.toggle('hidden', anyOpen || !inGame);
      }

      // Hand Dock: only show while Arrange modal is open
      const arrangeOpen = !$('arrangeModal')?.classList.contains('hidden');
      const dockHideIds = ['revealModal','gameOverModal','statusModal','reportModal','logModal','dealerPickPreModal'];
      const otherModalOpen = dockHideIds.some(id => {
        const n = $(id);
        return n && !n.classList.contains('hidden');
      });
      const hideDock = !arrangeOpen || otherModalOpen;

      const handDock = $('handDock');
      if (handDock) {
        handDock.classList.toggle('hidden', hideDock);
        // While arranging, hide bottom bar and move handDock to the very bottom
        handDock.style.bottom = arrangeOpen && !otherModalOpen ? '0px' : '';
      }

      const bottomBar = $('bottomBar');
      const btnShowBar = $('btnShowBar');
      const btnHideBar = $('btnHideBar');

      // Bottom bar behavior:
      // - Always hide while arranging (to maximize space)
      // - Otherwise, show/hide based on user toggle (clientState.bottomBarCollapsed)
      const forceHideBar = arrangeOpen;
      const collapsed = !!clientState.bottomBarCollapsed;

      if (bottomBar) bottomBar.classList.toggle('hidden', forceHideBar || collapsed);
      if (btnShowBar) btnShowBar.classList.toggle('hidden', forceHideBar || !collapsed);
      if (btnHideBar) btnHideBar.disabled = false;

      // Hide table floating reveal panels while any modal is open (avoid blocking modal UI)
      // IMPORTANT: do not clear innerHTML here, otherwise host may lose the reveal animation
      // if they settle while a modal (e.g. status) is open.
      if (anyOpen) {
        try {
          document.querySelectorAll('[id^="seatFloat_"]').forEach(n => {
            n.classList.add('hidden');
          });
        } catch {}
      } else {
        try {
          document.querySelectorAll('[id^="seatFloat_"]').forEach(n => {
            n.classList.remove('hidden');
          });
        } catch {}
      }

      // Danmaku should only show on the table (game page).
      // Allow showing during Chat (logModal), but hide during other modals to avoid blocking operations.
      const dan = $('danmaku');
      if (dan) {
        const inGame = !$('pageGame').classList.contains('hidden');
        const blockIds = ['revealModal','gameOverModal','statusModal','reportModal','dealerPickPreModal','arrangeModal'];
        const blockingOpen = blockIds.some(id => {
          const n = $(id);
          return n && !n.classList.contains('hidden');
        });
        const show = inGame && !blockingOpen; // chat modal is allowed
        if (!show) {
          dan.innerHTML = '';
          dan.classList.add('hidden');
        }
      }
    }

    // -------------------- Modal helpers --------------------
    function openRevealModal(payload) {
      if (!payload) return;
      clientState.lastReveal = payload;
      $('btnOpenLastReveal').classList.remove('hidden');

      $('revealRound').textContent = String(payload.round || '—');
      $('revealDealer').textContent = payload.dealerId ? getNameById(payload.dealerId) : '—';

      // score table
      const body = $('revealScoreBody');
      body.innerHTML = '';
      const players = payload.players || [];
      const dealerId = payload.dealerId;
      const results = payload.results || {};
      const subs = payload.submissions || {};
      const cumulative = payload.cumulative || {};

      const sorted = [...players].sort((a,b) => {
        if (a.id === dealerId) return -1;
        if (b.id === dealerId) return 1;
        return (results[b.id]?.total||0) - (results[a.id]?.total||0);
      });

      const mkScoreCell = (v) => {
        const s = v>0 ? `+${v}` : String(v);
        const cls = v>0 ? 'text-emerald-200' : (v<0 ? 'text-rose-200' : 'text-emerald-50/80');
        return el('td', `py-2 pr-2 mono ${cls}`, s);
      };

      for (const p of sorted) {
        const r = results[p.id] || {per:{head:0,mid:0,tail:0}, total:0, note:'', report:'none'};
        const sub = subs[p.id];
        const tr = document.createElement('tr');
        tr.className = 'border-b border-white/5 align-top';

        const tdName = el('td','py-2 pr-2');
        tdName.appendChild(el('div','text-sm text-slate-50', p.name + (p.id===dealerId?'（莊）':'')));
        tdName.appendChild(el('div','text-[10px] text-emerald-100/70 mono', p.id));

        const tdDealer = el('td','py-2 pr-2 text-xs text-slate-50', sub?.dealerCard ? cardLabel(sub.dealerCard) : '—');

        tr.appendChild(tdName);
        tr.appendChild(tdDealer);
        tr.appendChild(mkScoreCell(r.per?.head||0));
        tr.appendChild(mkScoreCell(r.per?.mid||0));
        tr.appendChild(mkScoreCell(r.per?.tail||0));

        const tdSpecial = el('td','py-2 pr-2 text-xs text-emerald-50/80');
        tdSpecial.textContent = r.report==='none' ? '—' : specialLabel(r.report);

        const tdRound = el('td','py-2 pr-2 font-black mono', String(r.total||0));
        tdRound.classList.add((r.total||0)>0 ? 'text-emerald-200' : ((r.total||0)<0 ? 'text-rose-200' : 'text-emerald-50/80'));

        const cumVal = Number(cumulative[p.id] || 0);
        const tdCum = el('td','py-2 pr-2 font-black mono', String(cumVal));
        tdCum.classList.add(cumVal>0 ? 'text-emerald-200' : (cumVal<0 ? 'text-rose-200' : 'text-emerald-50/80'));

        tr.appendChild(tdSpecial);
        tr.appendChild(tdRound);
        tr.appendChild(tdCum);
        tr.appendChild(el('td','py-2 pr-2 text-xs text-emerald-50/70', r.note || ''));

        body.appendChild(tr);
      }

      // hands detail
      const hands = $('revealHands');
      hands.innerHTML = '';
      for (const p of sorted) {
        const sub = subs[p.id];
        if (!sub) continue;
        const box = el('div','rounded-2xl bg-black/25 border border-white/10 p-3');
        const top = el('div','flex items-start justify-between gap-3');
        const left = el('div','min-w-0');
        left.appendChild(el('div','text-sm font-semibold text-slate-50 truncate', p.name + (p.id===dealerId?'（莊）':'')));
        left.appendChild(el('div','text-[10px] text-emerald-100/70 mono truncate', p.id));
        const right = el('div','text-right');
        const round = Number(results[p.id]?.total || 0);
        const cum = Number(cumulative[p.id] || 0);
        const line1 = el('div','text-xs', `本局：${round>0?'+':''}${round}`);
        line1.classList.add(round>0 ? 'text-emerald-200' : (round<0 ? 'text-rose-200' : 'text-emerald-50/80'));
        const line2 = el('div','text-xs', `累計：${cum>0?'+':''}${cum}`);
        line2.classList.add(cum>0 ? 'text-emerald-200' : (cum<0 ? 'text-rose-200' : 'text-emerald-50/80'));
        right.appendChild(line1);
        right.appendChild(line2);
        top.appendChild(left);
        top.appendChild(right);
        box.appendChild(top);

        const mkRow = (label, cards, evalName) => {
          const row = el('div','mt-2 grid gap-1');
          const title = el('div','text-xs text-emerald-100/80', label + (evalName ? `｜${evalName}` : ''));
          const cardsLine = el('div','text-sm text-slate-50');
          cardsLine.textContent = (cards||[]).map(cardLabel).join('  ');
          row.appendChild(title);
          row.appendChild(cardsLine);
          return row;
        };

        const eHead = eval2(sub.head);
        const eMid = eval3(sub.mid);
        const eTail = eval3(sub.tail);

        box.appendChild(mkRow('選莊牌', [sub.dealerCard], ''));
        box.appendChild(mkRow('頭墩', sub.head, eHead.name));
        box.appendChild(mkRow('中墩', sub.mid, eMid.name));
        box.appendChild(mkRow('尾墩', sub.tail, eTail.name));

        if ((sub.report||'none') !== 'none') {
          box.appendChild(el('div','mt-2 text-xs text-emerald-100/70', `報到：${specialLabel(sub.report)}`));
        }

        hands.appendChild(box);
      }

      // show modal
      $('revealModal').classList.remove('hidden');
      updateBodyOverflow();
    }

    function closeRevealModal() {
      $('revealModal').classList.add('hidden');
      updateBodyOverflow();

      // If final-round summary is pending, show it after closing reveal
      if (clientState.pendingGameOver) {
        const payload = clientState.pendingGameOver;
        clientState.pendingGameOver = null;
        openGameOverModal(payload);
      }
    }

    // -------------------- Arrange modal --------------------
    function syncArrangeSubmitStatus() {
      const t = $('submitStatus')?.textContent || '—';
      const n = $('submitStatus2');
      if (n) n.textContent = t;
    }

    function openArrangeModal() {
      syncArrangeSubmitStatus();
      $('arrangeModal').classList.remove('hidden');
      updateBodyOverflow();
      // ensure slots are rendered when opening
      try { renderGameHeader(); renderSlots(); renderHand(); } catch {}
      try { setArrangeTimerText(); } catch {}
    }

    function closeArrangeModal() {
      $('arrangeModal').classList.add('hidden');
      updateBodyOverflow();
    }

    // When a new hand is dealt, auto-close other modals so Arrange can be used immediately.
    function closeModalsForNewHand() {
      const ids = ['revealModal','statusModal','logModal','dealerPickPreModal','gameOverModal','reportModal'];
      for (const id of ids) {
        try { $(id)?.classList.add('hidden'); } catch {}
      }
      updateBodyOverflow();
    }

    // -------------------- Status/Report/Log modals --------------------
    function openStatusModal() {
      // Render latest lists before showing (avoid "卡住" due to empty content)
      $('statusRound').textContent = String(isHost ? hostState.round : clientState.round) || '—';
      try {
        renderReadyList(isHost ? readyMapForBroadcast() : null);
      } catch {}
      try {
        if (clientState.lastReveal) renderScores(clientState.lastReveal);
      } catch {}
      $('statusModal').classList.remove('hidden');
      updateBodyOverflow();
      updateMidActionButton();
    }
    function closeStatusModal() {
      $('statusModal').classList.add('hidden');
      updateBodyOverflow();
    }

    function openReportModal() {
      // Report selection is now inside Arrange modal
      openArrangeModal();
      setTimeout(() => {
        try { $('selReport')?.scrollIntoView({behavior:'smooth', block:'center'}); } catch {}
      }, 60);
    }
    function closeReportModal() {
      $('reportModal').classList.add('hidden');
      updateBodyOverflow();
    }

    function updateChatUnread() {
      const btnChat = $('btnOpenLog');
      const btnShow = $('btnShowBar');
      const open = !$('logModal').classList.contains('hidden');
      const unread = !!clientState.chatUnread && !open;

      const bottomBar = $('bottomBar');
      const barHidden = !bottomBar || bottomBar.classList.contains('hidden');

      if (btnChat) btnChat.classList.toggle('chat-unread', unread && !barHidden);
      if (btnShow) btnShow.classList.toggle('chat-unread', unread && barHidden);
    }

    function openLogModal() {
      $('logModal').classList.remove('hidden');
      // opening chat clears unread
      clientState.chatUnread = false;
      updateChatUnread();
      updateBodyOverflow();

      // Load stickers on-demand (GitHub API may rate-limit; retry when opening)
      try {
        initStickers(false);
      } catch {}

      // DEBUG: run a one-shot drive icon resolve for current known names
      try {
        if (!$('logModal').__driveDbgRun) {
          $('logModal').__driveDbgRun = true;
          const names = new Set();
          names.add(String(clientState.myName||'').trim());
          if (clientState.hostName) names.add(String(clientState.hostName||'').trim());
          if (isHost) {
            for (const pid in (hostState.players||{})) names.add(String(hostState.players[pid]?.name||'').trim());
          } else {
            for (const pid in (clientState.players||{})) names.add(String(clientState.players[pid]?.name||'').trim());
          }
          [...names].filter(Boolean).slice(0,12).forEach(n => {
            resolveDriveFileIdByName(n).catch(()=>{});
          });
        }
      } catch {}

      // Avoid auto-opening mobile keyboard when entering chat
      try {
        const isCoarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
        const isTouch = (navigator.maxTouchPoints || 0) > 0 || ('ontouchstart' in window);
        if (!isCoarse && !isTouch) {
          $('inpChat').focus();
        }
      } catch {}
    }
    function closeLogModal() {
      $('logModal').classList.add('hidden');
      updateBodyOverflow();
      updateChatUnread();
    }

    // -------------------- Scoreboard (DAY/MON) --------------------
    const scoreboardState = {
      tab: 'MON',
      cache: { MON: null },
      loading: false,
    };

    function setScoreboardTab(tab) {
      const t = String(tab||'DAY').toUpperCase();
      scoreboardState.tab = (t === 'MON' ? 'MON' : 'DAY');
      const btnDay = $('btnTabDay');
      const btnNig = $('btnTabNig'); // keep id for backward-compat UI
      if (btnDay && btnNig) {
        const on = 'bg-amber-400/15 text-amber-100 border-amber-200/20';
        const off = 'bg-white/10 hover:bg-white/15 text-emerald-50 border-white/10';
        btnDay.className = 'text-xs px-3 py-2 rounded-xl border font-black ' + (scoreboardState.tab==='DAY' ? on : off);
        btnNig.className = 'text-xs px-3 py-2 rounded-xl border font-black ' + (scoreboardState.tab==='MON' ? on : off);
      }
      renderScoreboardTable();
    }

    function setScoreboardStatus(text) {
      const eln = $('scoreboardStatus');
      if (eln) eln.textContent = text || '—';
    }

    function renderScoreboardTable() {
      const body = $('scoreboardBody');
      if (!body) return;
      body.innerHTML = '';
      const tab = scoreboardState.tab;
      const data = scoreboardState.cache[tab];
      const scores = (data && typeof data === 'object' && data.scoresByName && typeof data.scoresByName === 'object')
        ? data.scoresByName
        : {};

      const rows = Object.entries(scores)
        .map(([name, score]) => ({ name: String(name||''), score: Number(score||0) }))
        .filter(r => r.name)
        .sort((a,b) => b.score - a.score);

      if (!rows.length) {
        const tr = document.createElement('tr');
        tr.className = 'border-b border-white/5';
        const td = el('td','py-3 text-emerald-50/70 text-sm','尚無資料');
        td.colSpan = 3;
        tr.appendChild(td);
        body.appendChild(tr);
        return;
      }

      rows.forEach((r, idx) => {
        const tr = document.createElement('tr');
        tr.className = 'border-b border-white/5';
        tr.appendChild(el('td','py-2 pr-2 mono text-emerald-50/80', String(idx+1)));
        tr.appendChild(el('td','py-2 pr-2 text-slate-50 font-semibold', r.name));
        const v = r.score;
        const tdScore = el('td','py-2 pr-2 mono font-black', String(v));
        tdScore.classList.add(v>0?'text-emerald-200':(v<0?'text-rose-200':'text-emerald-50/80'));
        tr.appendChild(tdScore);
        body.appendChild(tr);
      });
    }

    async function fetchScoreboard(roomId) {
      let rid = String(roomId||'').trim().toUpperCase();
      // backward-compat: NIG is now MON
      if (rid === 'NIG' || rid === 'NIGHT') rid = 'MON';
      if (!['DAY','MON'].includes(rid)) return null;
      const url = `https://raw.githubusercontent.com/${PERSIST_REPO.owner}/${PERSIST_REPO.repo}/${PERSIST_REPO.branch}/${PERSIST_REPO.dir}/${encodeURIComponent(rid)}.json?bust=${Date.now()}`;
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    }

    async function loadScoreboard(force=false) {
      if (scoreboardState.loading) return;
      scoreboardState.loading = true;
      setScoreboardStatus('載入中…');
      try {
        if (force) { scoreboardState.cache.DAY = null; scoreboardState.cache.MON = null; }
        if (!scoreboardState.cache.DAY) scoreboardState.cache.DAY = await fetchScoreboard('DAY');
        if (!scoreboardState.cache.MON) scoreboardState.cache.MON = await fetchScoreboard('MON');
        const dayAt = scoreboardState.cache.DAY?.updatedAt ? String(scoreboardState.cache.DAY.updatedAt) : '';
        const monAt = scoreboardState.cache.MON?.updatedAt ? String(scoreboardState.cache.MON.updatedAt) : '';
        setScoreboardStatus(`DAY:${dayAt ? dayAt.slice(0,19).replace('T',' ') : '—'} | MON:${monAt ? monAt.slice(0,19).replace('T',' ') : '—'}`);
        renderScoreboardTable();
      } catch (e) {
        setScoreboardStatus('載入失敗：' + (e?.message || e));
        renderScoreboardTable();
      } finally {
        scoreboardState.loading = false;
      }
    }

    function openScoreboardModal() {
      $('scoreboardModal').classList.remove('hidden');
      updateBodyOverflow();
      // default tab DAY
      setScoreboardTab(scoreboardState.tab || 'DAY');
      loadScoreboard(false);
    }

    function closeScoreboardModal() {
      $('scoreboardModal').classList.add('hidden');
      updateBodyOverflow();
    }

    function sendChatText(text) {
      const t = String(text || '').trim();
      if (!t) return;

      const myName = clientState.myName || '我';

      // For players, ensure connected before showing locally (avoid "sent but not actually sent")
      if (!isHost) {
        if (!clientConn || !clientState.connected) {
          toast('尚未連線到房主');
          return;
        }
      }

      // append locally (chat record)
      glog(`${myName}：${t}`, {chat:true});
      // all chat content also goes to danmaku
      spawnDanmaku({kind:'text', text: t}, myName);

      // send to network
      const payload = {t:'chat', kind:'text', from: myName, fromId: (isHost ? hostId : myId), text: t};
      if (isHost) {
        broadcast(payload);
      } else {
        send(clientConn, payload);
      }
    }

    function sendChatSticker(url) {
      const u = String(url || '').trim();
      if (!u) return;

      const myName = clientState.myName || '我';

      if (!isHost) {
        if (!clientConn || !clientState.connected) {
          toast('尚未連線到房主');
          return;
        }
      }

      // record in chat
      glog(`${myName}：`, {chat:true, kind:'sticker', url: u});
      // danmaku
      spawnDanmaku({kind:'sticker', url: u}, myName);

      const payload = {t:'chat', kind:'sticker', from: myName, fromId: (isHost ? hostId : myId), url: u};
      if (isHost) {
        broadcast(payload);
      } else {
        send(clientConn, payload);
      }
    }

    // Sticker loader: GitHub API may be rate-limited; add timeout + cache fallback.
    let stickersInitPromise = null;

    async function initStickers(force=false) {
      if (stickersInitPromise && !force) return stickersInitPromise;

      const root = $('chatStickers');
      const status = $('stickerStatus');
      if (!root || !status) return;

      // Allow tapping status to retry
      if (!status.__retryBound) {
        status.__retryBound = true;
        status.style.cursor = 'pointer';
        status.title = '點擊重試載入 Sticker';
        status.addEventListener('click', () => initStickers(true));
      }

      const load = async () => {
        root.innerHTML = '';
        status.textContent = '載入中…（點擊可重試）';

        const api = 'https://api.github.com/repos/hketerrell/HKE9/contents/sticker?ref=main';

        const fetchJsonWithTimeout = async (url, ms=10000) => {
          const ctrl = new AbortController();
          const t = setTimeout(() => ctrl.abort('timeout'), ms);
          try {
            const res = await fetch(url, { cache: 'no-store', signal: ctrl.signal });
            const text = await res.text();
            let json = null;
            try { json = JSON.parse(text); } catch { json = null; }
            return { ok: res.ok, status: res.status, json, text };
          } finally {
            clearTimeout(t);
          }
        };

        const fromCache = () => {
          try {
            const raw = localStorage.getItem('ninePokerStickersCache');
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!Array.isArray(parsed) || parsed.length === 0) return null;
            return parsed;
          } catch {
            return null;
          }
        };

        const renderFiles = (files, label='Sticker') => {
          const safe = (Array.isArray(files) ? files : [])
            .filter(x => x && x.url)
            .map(x => ({ name: String(x.name||''), url: String(x.url||'') }))
            .filter(x => x.url);

          if (!safe.length) {
            status.textContent = '未找到 sticker';
            return;
          }

          status.textContent = `${label}：${safe.length} 個（點擊可重試）`;

          for (const f of safe) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'rounded-xl bg-white/5 hover:bg-white/10 border border-white/10 p-1 active:scale-[0.99] transition';
            const img = document.createElement('img');
            img.src = f.url;
            img.alt = f.name;
            img.loading = 'lazy';
            img.className = 'w-full h-auto';
            btn.appendChild(img);
            btn.addEventListener('click', () => sendChatSticker(f.url));
            root.appendChild(btn);
          }
        };

        try {
          const res = await fetchJsonWithTimeout(api, 10000);

          // Rate limit / forbidden
          if (!res.ok) {
            const msg = (res?.json && (res.json.message || res.json.error)) ? String(res.json.message || res.json.error) : `HTTP ${res.status}`;
            // fallback to cache
            const cached = fromCache();
            if (cached) {
              renderFiles(cached, 'Sticker（快取）');
              log('Sticker API failed, fallback to cache: ' + msg);
              return;
            }
            status.textContent = `Sticker 載入失敗（${msg}，點擊重試）`;
            log('Sticker load error: ' + msg);
            return;
          }

          const list = Array.isArray(res.json) ? res.json : [];
          const files = list
            .filter(x => {
              if (!x || x.type !== 'file' || !x.download_url) return false;
              const n = String(x.name || '').toLowerCase();
              return n.endsWith('.png') || n.endsWith('.webp');
            })
            .sort((a,b) => String(a.name||'').localeCompare(String(b.name||'')))
            .map(x => ({ name: x.name, url: x.download_url }));

          if (!files.length) {
            status.textContent = '未找到 sticker（點擊重試）';
            return;
          }

          // Cache for later (in case of GitHub API rate limit)
          try { localStorage.setItem('ninePokerStickersCache', JSON.stringify(files)); } catch {}

          renderFiles(files, 'Sticker');
        } catch (e) {
          const msg = (e?.name === 'AbortError') ? '逾時' : (e?.message || String(e));
          const cached = fromCache();
          if (cached) {
            renderFiles(cached, 'Sticker（快取）');
            log('Sticker load timeout/error, fallback to cache: ' + msg);
            return;
          }
          status.textContent = `Sticker 載入失敗（${msg}，點擊重試）`;
          log('Sticker load error: ' + msg);
        }
      };

      stickersInitPromise = load().finally(() => {
        stickersInitPromise = null;
      });

      return stickersInitPromise;
    }

    function spawnDanmaku(payload, from='') {
      const root = $('danmaku');
      if (!root) return;

      // Danmaku only on table view (pageGame).
      // Allow showing during Chat (logModal), but block during other modals.
      const inGame = !$('pageGame').classList.contains('hidden');
      const blockIds = ['revealModal','gameOverModal','statusModal','reportModal','dealerPickPreModal','arrangeModal'];
      const blockingOpen = blockIds.some(id => {
        const n = $(id);
        return n && !n.classList.contains('hidden');
      });
      if (!inGame || blockingOpen) return;

      root.classList.remove('hidden');

      const p = (payload && typeof payload === 'object') ? payload : {kind:'text', text:String(payload||'')};
      const kind = p.kind || 'text';

      const line = document.createElement('div');
      line.className = 'danmaku-item' + (kind === 'sticker' ? ' sticker' : '');

      const who = from ? `${from}：` : '';
      if (kind === 'sticker' && p.url) {
        // Sticker danmaku
        const whoSpan = el('span', 'mr-2');
        whoSpan.textContent = who;
        line.appendChild(whoSpan);

        const img = document.createElement('img');
        img.src = String(p.url);
        img.alt = 'sticker';
        img.loading = 'lazy';
        line.appendChild(img);
      } else {
        const msg = String(p.text || '').trim();
        if (!msg) return;
        line.textContent = who + msg;
      }

      // random track
      const h = window.innerHeight;
      const topMin = 72;
      const topMax = Math.max(topMin, h - 180);
      const top = topMin + Math.floor(Math.random() * (topMax - topMin));
      line.style.top = top + 'px';

      const duration = 6500 + Math.random() * 2500;
      line.style.animation = `danmakuFly ${duration}ms linear forwards`;

      root.appendChild(line);

      const cleanup = () => {
        try { line.remove(); } catch {}
        if (root.childElementCount === 0) root.classList.add('hidden');
      };
      line.addEventListener('animationend', cleanup);
      setTimeout(cleanup, duration + 200);
    }

    function sendDanmakuText(text) {
      const t = String(text || '').trim();
      if (!t) return;

      const myName = clientState.myName || '我';

      // must be connected if player
      if (!isHost) {
        if (!clientConn || !clientState.connected) {
          toast('尚未連線到房主');
          return;
        }
      }

      // show locally immediately
      spawnDanmaku({kind:'text', text: t}, myName);

      // send to network
      if (isHost) {
        broadcast({t:'danmaku', kind:'text', from: myName, fromId: hostId, text: t});
      } else {
        send(clientConn, {t:'danmaku', kind:'text', from: myName, fromId: myId, text: t});
      }
    }

    // -------------------- Seat prank: poop (throw) --------------------
    function seatCenter(pid) {
      const n = document.getElementById('seatBadge_' + pid);
      if (!n) return null;
      const r = n.getBoundingClientRect();
      return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
    }

    async function spawnPoopThrow(fromId, targetId) {
      const from = seatCenter(fromId);
      const to = seatCenter(targetId);
      if (!from || !to) {
        spawnPoopOnSeat(targetId);
        return;
      }

      const node = document.createElement('div');
      node.className = 'poop-throw';
      node.textContent = '💩';
      document.body.appendChild(node);

      const duration = 520;
      const start = performance.now();
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      const peak = -Math.min(180, 90 + Math.hypot(dx, dy) * 0.15);

      function easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }

      return await new Promise((resolve) => {
        function tick(now) {
          const t = Math.min(1, (now - start) / duration);
          const e = easeOutCubic(t);

          const x = from.x + dx * e;
          const y = from.y + dy * e + peak * (4 * e * (1 - e));
          const rot = 720 * e;

          node.style.left = x + 'px';
          node.style.top = y + 'px';
          node.style.transform = `translate(-50%, -50%) rotate(${rot}deg) scale(${0.9 + 0.2 * (1 - Math.abs(0.5 - e) * 2)})`;

          if (t < 1) {
            requestAnimationFrame(tick);
          } else {
            try { node.remove(); } catch {}
            spawnPoopOnSeat(targetId);
            resolve();
          }
        }
        requestAnimationFrame(tick);
      });
    }

    function spawnPoopOnSeat(targetId) {
      const box = document.getElementById('seatBadge_' + targetId);
      if (!box) return;
      // overlay inside the seat badge
      const poop = document.createElement('div');
      poop.className = 'poop-item';
      poop.textContent = '💩';
      box.appendChild(poop);
      setTimeout(() => {
        try { poop.remove(); } catch {}
      }, 980);
    }

    function sendPoopTo(targetId) {
      const tid = String(targetId || '');
      if (!tid) return;

      const fromId = isHost ? hostId : myId;
      const fromName = clientState.myName || '我';

      // must be connected if player
      if (!isHost) {
        if (!clientConn || !clientState.connected) {
          toast('尚未連線到房主');
          return;
        }
      }

      // play locally immediately (throw)
      spawnPoopThrow(fromId, tid);

      // send to network
      if (isHost) {
        broadcast({t:'poop', from: fromName, fromId, targetId: tid});
      } else {
        send(clientConn, {t:'poop', from: fromName, fromId, targetId: tid});
      }
    }

    // -------------------- Dealer Pick (Pre-Reveal) --------------------
    let dealerPickPreSelectedId = null;
    let dealerPickPreCtx = null; // {kind, controllerId, submissions, players}

    function renderDealerPickPreLists() {
      if (!dealerPickPreCtx) return;
      const ctx = dealerPickPreCtx;

      const subs = ctx?.submissions || {};
      const players = ctx?.players || [];

      // Combined list: each row shows player + their dealerCard, click to choose dealer
      const listRoot = $('dealerPickPreList');
      if (!listRoot) return;
      listRoot.innerHTML = '';

      for (const p of players) {
        const sub = subs[p.id];
        const dc = sub?.dealerCard ? cardLabel(sub.dealerCard) : '—';

        const row = el('button','text-left w-full rounded-xl bg-black/20 border border-white/10 px-3 py-2 hover:bg-black/25');
        row.type = 'button';

        const top = el('div','flex items-center justify-between gap-2');
        const left = el('div','min-w-0');
        left.appendChild(el('div','text-sm text-slate-50 truncate', p.name));
        left.appendChild(el('div','text-[10px] text-emerald-100/70 mono truncate', p.id));

        const right = el('div','flex items-center gap-2');
        const dcBadge = el('div','text-xs font-black text-amber-100 mono', dc);

        const selected = dealerPickPreSelectedId === p.id;
        const pickBadge = el('div','text-[11px] px-2 py-1 rounded-full border');
        pickBadge.className = 'text-[11px] px-2 py-1 rounded-full border ' + (selected
          ? 'bg-amber-400/15 border-amber-200/30 text-amber-100'
          : 'bg-white/5 border-white/10 text-emerald-50/70');
        pickBadge.textContent = selected ? '已選' : '點選';

        right.appendChild(dcBadge);
        right.appendChild(pickBadge);

        top.appendChild(left);
        top.appendChild(right);
        row.appendChild(top);

        row.addEventListener('click', (e) => {
          e.preventDefault();
          dealerPickPreSelectedId = p.id;
          renderDealerPickPreLists();
        });

        listRoot.appendChild(row);
      }
    }

    function openDealerPickPreModal(ctx) {
      dealerPickPreCtx = ctx;
      dealerPickPreSelectedId = ctx?.currentDealerId || dealerPickPreSelectedId || null;

      const isBig = ctx?.kind === 'BJ';
      $('dealerPickPreTitle').textContent = isBig ? '你持有大鬼（本局你可指定莊家）' : '你持有細鬼（本局你可指定莊家）';
      $('dealerPickPreDesc').textContent = isBig
        ? '請先查看各玩家選莊牌，然後指定本局莊家。'
        : '請先查看各玩家選莊牌，然後指定本局莊家（若有人持有大鬼，你將不會看到此畫面）。';

      renderDealerPickPreLists();

      $('dealerPickPreModal').classList.remove('hidden');
      updateBodyOverflow();
    }

    function closeDealerPickPreModal() {
      $('dealerPickPreModal').classList.add('hidden');
      updateBodyOverflow();
    }

    function hasAnyJokerDealerCard(submissions) {
      for (const id in (submissions || {})) {
        const dc = submissions[id]?.dealerCard;
        if (dc?.s === 'J') return true;
      }
      return false;
    }

    function findDealerPickController(submissions) {
      // Returns {controllerId, kind:'BJ'|'SJ'} or null
      const ids = Object.keys(submissions || {});
      const big = ids.filter(id => submissions[id]?.dealerCard?.s==='J' && submissions[id].dealerCard.j==='BJ');
      if (big.length) {
        // pick deterministic: smallest id
        big.sort();
        return {controllerId: big[0], kind:'BJ'};
      }
      const small = ids.filter(id => submissions[id]?.dealerCard?.s==='J' && submissions[id].dealerCard.j==='SJ');
      if (small.length) {
        small.sort();
        return {controllerId: small[0], kind:'SJ'};
      }
      return null;
    }

    // -------------------- Game Over modal + confetti --------------------
    let confettiTimer = null;

    function resizeConfetti() {
      const c = $('confetti');
      if (!c) return;
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      c.width = Math.floor(window.innerWidth * dpr);
      c.height = Math.floor(window.innerHeight * dpr);
      c._dpr = dpr;
    }

    function startConfetti(ms=2200) {
      const c = $('confetti');
      if (!c) return;
      resizeConfetti();
      c.classList.remove('hidden');
      const ctx = c.getContext('2d');
      const dpr = c._dpr || 1;

      const colors = ['#facc15', '#34d399', '#60a5fa', '#f472b6', '#fb7185', '#a78bfa'];
      const N = 110;
      const parts = Array.from({length:N}, () => ({
        x: Math.random()*window.innerWidth,
        y: -20 - Math.random()*window.innerHeight*0.3,
        vy: 1.2 + Math.random()*2.6,
        vx: -1.2 + Math.random()*2.4,
        r: 2 + Math.random()*4,
        rot: Math.random()*Math.PI,
        vr: (-0.2 + Math.random()*0.4),
        color: colors[Math.floor(Math.random()*colors.length)],
        life: 0,
      }));

      let start = performance.now();
      function tick(t) {
        const elapsed = t - start;
        ctx.clearRect(0,0,c.width,c.height);
        ctx.save();
        ctx.scale(dpr,dpr);

        for (const p of parts) {
          p.life += 1;
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.02;
          p.rot += p.vr;

          // wrap sides
          if (p.x < -20) p.x = window.innerWidth + 20;
          if (p.x > window.innerWidth + 20) p.x = -20;

          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillStyle = p.color;
          ctx.fillRect(-p.r, -p.r*0.6, p.r*2, p.r*1.2);
          ctx.restore();
        }

        ctx.restore();
        if (elapsed < ms) {
          confettiTimer = requestAnimationFrame(tick);
        } else {
          stopConfetti();
        }
      }
      stopConfetti();
      confettiTimer = requestAnimationFrame(tick);
    }

    function stopConfetti() {
      if (confettiTimer) {
        cancelAnimationFrame(confettiTimer);
        confettiTimer = null;
      }
      const c = $('confetti');
      if (c) {
        const ctx = c.getContext('2d');
        ctx.clearRect(0,0,c.width,c.height);
        c.classList.add('hidden');
      }
    }

    function openGameOverModal(payload) {
      if (!payload) return;
      $('gameOverRoom').textContent = payload.roomId || (isHost ? (myId||'—') : (clientState.roomId||'—'));

      const body = $('gameOverBody');
      body.innerHTML = '';
      const players = payload.players || [];
      const cumulative = payload.cumulative || {};
      const sorted = [...players].sort((a,b) => Number(cumulative[b.id]||0) - Number(cumulative[a.id]||0));

      for (const p of sorted) {
        const tr = document.createElement('tr');
        tr.className = 'border-b border-white/5 align-top';
        const tdName = el('td','py-2 pr-2');
        tdName.appendChild(el('div','text-sm text-slate-50', p.name));
        tdName.appendChild(el('div','text-[10px] text-emerald-100/70 mono', p.id));
        const v = Number(cumulative[p.id]||0);
        const tdScore = el('td','py-2 pr-2 font-black mono', String(v));
        tdScore.classList.add(v>0?'text-emerald-200':(v<0?'text-rose-200':'text-emerald-50/80'));
        tr.appendChild(tdName);
        tr.appendChild(tdScore);
        body.appendChild(tr);
      }

      $('gameOverModal').classList.remove('hidden');
      updateBodyOverflow();
      startConfetti(2400);
    }

    function closeGameOverModal() {
      $('gameOverModal').classList.add('hidden');
      updateBodyOverflow();
      stopConfetti();
    }

    window.addEventListener('resize', () => {
      const c = $('confetti');
      if (c && !c.classList.contains('hidden')) resizeConfetti();
    });

    // -------------------- Card model --------------------
    const SUITS = ['S','H','D','C'];
    const SUIT_ICON = {S:'♠', H:'♥', D:'♦', C:'♣'};
    const SUIT_COLOR = {S:'text-slate-900', C:'text-slate-900', H:'text-rose-600', D:'text-rose-600'};

    function makeDeck54() {
      const deck = [];
      for (const s of SUITS) {
        for (let r=2;r<=14;r++) deck.push({r, s});
      }
      deck.push({r: 16, s:'J', j:'BJ'}); // 大鬼
      deck.push({r: 15, s:'J', j:'SJ'}); // 細鬼
      return deck;
    }

    function cardLabel(c) {
      if (!c) return '—';
      if (c.s === 'J') return c.j === 'BJ' ? '大鬼' : '細鬼';
      const rank = c.r;
      const rtxt = rank<=10 ? String(rank) : (rank===11?'J':rank===12?'Q':rank===13?'K':'A');
      return `${rtxt}${SUIT_ICON[c.s]}`;
    }

    function cardKey(c) {
      if (c.s==='J') return c.j;
      return `${c.r}${c.s}`;
    }

    function compareSelectCard(a,b) {
      // 大鬼/細鬼最高，其次點數，再比花色 S>H>D>C
      const suitOrder = {S:4,H:3,D:2,C:1,J:5};
      const ra = (a.s==='J') ? 100 : a.r;
      const rb = (b.s==='J') ? 100 : b.r;
      if (ra !== rb) return ra - rb;
      return (suitOrder[a.s]||0) - (suitOrder[b.s]||0);
    }

    function shuffle(arr) {
      for (let i=arr.length-1;i>0;i--) {
        const j = Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]]=[arr[j],arr[i]];
      }
      return arr;
    }

    // -------------------- 2-card / 3-card evaluation w/ 鬼牌 --------------------
    function eval2(cards) {
      const jokers = cards.filter(c => c?.s==='J').length;
      if (jokers === 0) return eval2NoJoker(cards);

      const base = cards.filter(c => c && c.s!=='J');
      const used = new Set(base.map(cardKey));
      const full = [];
      for (const s of SUITS) {
        for (let r=2;r<=14;r++) {
          const k = `${r}${s}`;
          if (!used.has(k)) full.push({r,s});
        }
      }

      const best = {cat:-1, t:[], name:''};
      const tryHand = (h) => {
        const e = eval2NoJoker(h);
        if (compareEval(e, best) > 0) {
          best.cat = e.cat; best.t = e.t; best.name = e.name;
        }
      };

      if (jokers === 1) {
        for (const rep of full) tryHand(base.concat([rep]));
      } else {
        for (let i=0;i<full.length;i++) {
          for (let j=i+1;j<full.length;j++) tryHand(base.concat([full[i], full[j]]));
        }
      }

      return {cat: best.cat, t: best.t, name: best.name, usedJoker: true};
    }

    function eval2NoJoker(cards) {
      const ranks = cards.map(c=>c.r).sort((a,b)=>b-a);
      const uniq = [...new Set(ranks)];
      if (uniq.length === 1) return {cat:1, t:[uniq[0]], name:'一對'};
      return {cat:0, t:ranks, name:'高牌'};
    }

    function eval3(cards) {
      const jokers = cards.filter(c => c.s==='J').length;
      if (jokers === 0) return eval3NoJoker(cards);

      const base = cards.filter(c => c.s!=='J');
      const used = new Set(base.map(cardKey));
      const full = [];
      for (const s of SUITS) {
        for (let r=2;r<=14;r++) {
          const k = `${r}${s}`;
          if (!used.has(k)) full.push({r,s});
        }
      }

      const best = {cat:-1, t:[], name:''};
      const tryHand = (h) => {
        const e = eval3NoJoker(h);
        if (compareEval(e, best) > 0) {
          best.cat = e.cat; best.t = e.t; best.name = e.name;
        }
      };

      if (jokers === 1) {
        for (const rep of full) tryHand(base.concat([rep]));
      } else {
        for (let i=0;i<full.length;i++) {
          for (let j=i+1;j<full.length;j++) tryHand(base.concat([full[i], full[j]]));
        }
      }

      return {cat: best.cat, t: best.t, name: best.name, usedJoker: true};
    }

function eval3NoJoker(cards) {
      const ranks = cards.map(c=>c.r).sort((a,b)=>b-a);
      const suits = cards.map(c=>c.s);
      const isFlush = suits.every(s=>s===suits[0]);

      const uniq = [...new Set(ranks)];
      const counts = {};
      for (const r of ranks) counts[r]=(counts[r]||0)+1;
      const sortedAsc = [...ranks].sort((a,b)=>a-b);
      let isStraight = false;
      let straightHigh = Math.max(...ranks);

      if (uniq.length === 3) {
        // 一般順子判斷 (例如 4-5-6)
        if (sortedAsc[2]-sortedAsc[1]===1 && sortedAsc[1]-sortedAsc[0]===1) {
          isStraight = true;
          straightHigh = sortedAsc[2];
          
          // 【修正邏輯】如果是 Q-K-A (12,13,14)，原本最大是 14 (A)，
          // 為了確保它大於 A-2-3，我們將其權重手動設為 15
          if (straightHigh === 14) {
            straightHigh = 15;
          }
        } 
        // A-2-3 特殊順子判斷 (2,3,14)
        else if (sortedAsc[0]===2 && sortedAsc[1]===3 && sortedAsc[2]===14) {
          isStraight = true;
          
          // 【修正邏輯】原本這裡是 straightHigh = 3 (導致比輸 4-5-6)
          // 這裡改為 14，讓它大於一般的 K-Q-J (13)，僅次於 Q-K-A (15)
          straightHigh = 14; 
        }
      }



      // 5 StraightFlush, 4 Trips, 3 Straight, 1 Pair, 0 High
      if (isStraight && isFlush) return {cat:5, t:[straightHigh], name:'同花順'};
      if (uniq.length === 1) return {cat:4, t:[uniq[0]], name:'三條'};
      if (isStraight) return {cat:3, t:[straightHigh], name:'順子'};
      if (uniq.length === 2) {
        let pairRank = null, kicker = null;
        for (const r in counts) {
          if (counts[r]===2) pairRank = Number(r);
          if (counts[r]===1) kicker = Number(r);
        }
        return {cat:1, t:[pairRank, kicker], name:'一對'};
      }
      return {cat:0, t:ranks, name:'高牌'};
    }

    function compareEval(a,b) {
      if (a.cat !== b.cat) return a.cat - b.cat;
      const len = Math.max(a.t.length, b.t.length);
      for (let i=0;i<len;i++) {
        const av = a.t[i] ?? 0;
        const bv = b.t[i] ?? 0;
        if (av !== bv) return av - bv;
      }
      return 0;
    }

    // -------------------- Scoring helpers (vs dealer) --------------------
    // 頭墩：若勝方為一對，該墩得分 = 對子點數（2~14）；否則勝方得 1。
    function headWinPoints(e2) {
      if (e2?.cat === 1) {
        const r = Number(e2.t?.[0] || 0);
        if (r >= 2 && r <= 14) return r;
      }
      return 1;
    }
    function headSectionScore(playerE, dealerE) {
      const cmp = Math.sign(compareEval(playerE, dealerE));
      if (cmp === 0) return -railWinPoints(dealerE);
      if (cmp > 0) return headWinPoints(playerE);
      return -headWinPoints(dealerE);
    }

    // 中墩：同花順 +10；三條 +6；其他勝方得 1。
    function midWinPoints(e3) {
      if (e3?.cat === 5) return 10;
      if (e3?.cat === 4) return 6;
      return 1;
    }
    function midSectionScore(playerE, dealerE) {
      const cmp = Math.sign(compareEval(playerE, dealerE));
      if (cmp === 0) return -railWinPoints(dealerE);
      if (cmp > 0) return midWinPoints(playerE);
      return -midWinPoints(dealerE);
    }

    // 尾墩：同花順 +5；三條 +3；其他勝方得 1。
    function tailWinPoints(e3) {
      if (e3?.cat === 5) return 5;
      if (e3?.cat === 4) return 3;
      return 1;
    }
    function tailSectionScore(playerE, dealerE) {
      const cmp = Math.sign(compareEval(playerE, dealerE));
      if (cmp === 0) return -railWinPoints(dealerE);
      if (cmp > 0) return tailWinPoints(playerE);
      return -tailWinPoints(dealerE);
    }

    function strength2(cards) {
      const e = eval2(cards);
      const t = e.t;
      return e.cat*1e9 + (t[0]||0)*1e6 + (t[1]||0)*1e3;
    }

    function strength3(cards) {
      const e = eval3(cards);
      const t = e.t;
      return e.cat*1e9 + (t[0]||0)*1e6 + (t[1]||0)*1e3 + (t[2]||0);
    }

    function isAllFilled(arr) {
      return arr.every(x=>x);
    }

    function detectFoul(head, mid, tail) {
      if (!isAllFilled(head) || !isAllFilled(mid) || !isAllFilled(tail)) return {foul:false};
      const sh = strength2(head);
      const sm = strength3(mid);
      const st = strength3(tail);
      if (sh > sm) return {foul:true, msg:'擺烏龍：頭墩大於中墩'};
      if (sm > st) return {foul:true, msg:'擺烏龍：中墩大於尾墩'};
      return {foul:false};
    }

    function canBeFlush2(cards) {
      const nonJ = cards.filter(c=>c && c.s!=='J');
      if (nonJ.length <= 1) return true;
      return nonJ.every(c=>c.s===nonJ[0].s);
    }
    function canBeStraight2(cards) {
      const nonJ = cards.filter(c=>c && c.s!=='J');
      const jokers = cards.filter(c=>c && c.s==='J').length;
      if (jokers >= 1) return true; // one joker can always make an adjacent
      if (nonJ.length !== 2) return true;
      const a = nonJ[0].r, b = nonJ[1].r;
      const hi = Math.max(a,b), lo = Math.min(a,b);
      if (hi-lo===1) return true;
      if ((hi===14 && lo===2)) return true;
      return false;
    }

    // -------------------- 報到 --------------------
    function specialLabel(code) {
      const map = {
        none: '—',
        allRed: '全紅 +5（全紅色牌）',
        allBlack: '全黑 +5（全黑色牌）',
        threeSnake: '三蛇 +3（三順子）',
        fourKind: '4條 +10（鐵支）',
        fourPairs: '4對 +10（四對子）',
        mixedDragon: '雜龍 +15（牌順序由小至大）',
        threeStraightFlush: '3同花順 +25（三同花順）',
        twoFourKind: '2個4條 +30（2對鐵支）',
        greenDragon: '青龍 +100（一樣顏色牌順序由小至大）',
        noHand: '百無 +3（3高牌）',
      };
      return map[code] || code;
    }

    function validateSpecial(code, all9Cards, sub, evals) {
      const c = code || 'none';
      if (c === 'none') return {ok:true, bonus:0};

      const all = (all9Cards || []).filter(Boolean);
      const jokers = all.filter(x => x.s === 'J').length;
      const nonJ = all.filter(x => x.s !== 'J');

      const bonusMap = {
        allRed: 5,
        allBlack: 5,
        threeSnake: 3,
        fourKind: 10,
        fourPairs: 10,
        mixedDragon: 15,
        threeStraightFlush: 25,
        twoFourKind: 30,
        greenDragon: 100,
        noHand: 3,
      };

      const isRed = (s) => s === 'H' || s === 'D';
      const isBlack = (s) => s === 'S' || s === 'C';

      const rankCounts = () => {
        const m = {};
        for (const x of nonJ) m[x.r] = (m[x.r]||0) + 1;
        return m;
      };

      const canMakeFourKindCount = () => {
        const counts = rankCounts();
        const ranks = Object.keys(counts).map(Number);
        for (const r of ranks) {
          if ((counts[r]||0) + jokers >= 4) return true;
        }
        return jokers >= 4;
      };

      const canMakeTwoFourKind = () => {
        const counts = rankCounts();
        const ranks = Object.keys(counts).map(Number).sort((a,b)=>(counts[b]-counts[a]));
        let j = jokers;
        let made = 0;
        for (const r of ranks) {
          const need = Math.max(0, 4 - (counts[r]||0));
          if (need <= j) {
            j -= need;
            made += 1;
            if (made >= 2) return true;
          }
        }
        // could make with only jokers
        if (made === 1 && j >= 4) return true;
        if (made === 0 && j >= 8) return true;
        return false;
      };

      const canMakeFourPairs = () => {
        const counts = rankCounts();
        let pairs = 0;
        let singles = 0;
        for (const r in counts) {
          pairs += Math.floor(counts[r]/2);
          singles += counts[r] % 2;
        }
        // use jokers to pair singles first
        const useToPairSingles = Math.min(jokers, singles);
        pairs += useToPairSingles;
        let jLeft = jokers - useToPairSingles;
        // remaining jokers can form pairs by themselves
        pairs += Math.floor(jLeft / 2);
        return pairs >= 4;
      };

      const canMakeLength9Straight = (requireSameColor=null) => {
        if (requireSameColor) {
            if (requireSameColor === 'red' && nonJ.some(x => !isRed(x.s))) return false;
            if (requireSameColor === 'black' && nonJ.some(x => !isBlack(x.s))) return false;
        }

          const ranks = nonJ.map(x => x.r);
          const uniq = new Set(ranks);
          // 雜龍規則：非鬼牌部分不可有對子 (若有對子則無法構成 9 張連續)
          if (uniq.size !== ranks.length) return false;

          // 全鬼牌或只剩1張牌，一定成功
          if (ranks.length <= 1) return true;

          // 邏輯：需要的鬼牌數量 = (最大值 - 最小值 + 1) - 實際張數
          // 只要 缺少的張數 <= 擁有的鬼牌數 (jokers) 即可

          // 情況 1: Ace 當作 14 (例如 6,7,8,9,10,J,Q,K,A)
          const max14 = Math.max(...ranks);
          const min14 = Math.min(...ranks);
          const need14 = (max14 - min14 + 1) - ranks.length;
          if (need14 <= jokers) return true;

          // 情況 2: Ace 當作 1 (例如 A,2,3,4,5,6,7,8,9)
          if (ranks.includes(14)) {
            // 把 14 轉成 1
            const ranks1 = ranks.map(r => r === 14 ? 1 : r);
            const max1 = Math.max(...ranks1);
            const min1 = Math.min(...ranks1);
            const need1 = (max1 - min1 + 1) - ranks1.length;
            if (need1 <= jokers) return true;
          }

          return false;
        };

      // 2/3/3 版本的「三蛇 / 三同花順 / 百無」用各墩判斷（頭墩為 2 張用 canBeStraight2/canBeFlush2）
      const head = sub?.head || [];
      const mid = sub?.mid || [];
      const tail = sub?.tail || [];
      const eHead = evals?.head || eval2(head);
      const eMid = evals?.mid || eval3(mid);
      const eTail = evals?.tail || eval3(tail);

      // 報到：全紅/全黑只以「頭+中+尾」8 張判斷（不含選莊牌），並忽略鬼牌顏色
      const eightCards = [...(head || []), ...(mid || []), ...(tail || [])].filter(Boolean);
      const eightNonJ = eightCards.filter(x => x.s !== 'J');

      let ok = false;
      if (c === 'allRed') ok = eightNonJ.every(x => isRed(x.s));
      if (c === 'allBlack') ok = eightNonJ.every(x => isBlack(x.s));
      if (c === 'threeSnake') ok = canBeStraight2(head) && eMid.cat >= 3 && eTail.cat >= 3; // mid/tail are straight or straight flush
      if (c === 'threeStraightFlush') ok = canBeStraight2(head) && canBeFlush2(head) && eMid.cat === 5 && eTail.cat === 5;
      if (c === 'noHand') {
        // 百無（3高牌）：不允許「刻意拆牌」來達成。
        // 規則：只看頭/中/尾墩的 8 張牌（不含選莊牌）。
        // 只要這 8 張牌在任何 3 張組合下「可以」構成任何牌型（對子/順子/三條/同花順；鬼牌百搭），就視為報到失敗。
        // 注意：本遊戲已刪除「同花」牌型，因此「三張同花」不應令百無失敗。
        // 這裡用枚舉 8C3 的方式判斷（不看花色同花，僅看 eval3NoJoker 的 cat>0）。
        const eight = [...(head || []), ...(mid || []), ...(tail || [])].filter(Boolean);
        const anyJoker = eight.some(x => x.s === 'J');
        if (anyJoker) {
          ok = false;
        } else {
          // Quick reject: any duplicate ranks => can form a pair
          const ranks = eight.map(x => x.r);
          const set = new Set(ranks);
          if (set.size !== ranks.length) {
            ok = false;
          } else {
            let canMakeAnyHand = false;
            for (let i=0;i<eight.length;i++) {
              for (let j=i+1;j<eight.length;j++) {
                for (let k=j+1;k<eight.length;k++) {
                  const e3 = eval3NoJoker([eight[i], eight[j], eight[k]]);
                  // eval3NoJoker: cat>0 means (pair/straight/trips/straight flush). "同花"已刪除，不會出現 cat=2。
                  if ((e3?.cat || 0) > 0) {
                    canMakeAnyHand = true;
                    break;
                  }
                }
                if (canMakeAnyHand) break;
              }
              if (canMakeAnyHand) break;
            }
            ok = !canMakeAnyHand;
          }
        }
      }

      if (c === 'fourKind') ok = canMakeFourKindCount();
      if (c === 'twoFourKind') ok = canMakeTwoFourKind();
      if (c === 'fourPairs') ok = canMakeFourPairs();
      if (c === 'mixedDragon') ok = canMakeLength9Straight(null);
      if (c === 'greenDragon') {
        // same color + length 9 straight
        ok = canMakeLength9Straight('red') || canMakeLength9Straight('black');
      }

      return {ok, bonus: ok ? (bonusMap[c] || 0) : 0};
    }

    // -------------------- Relay (WebSocket) networking --------------------
    const DEFAULT_RELAY_URL = 'https://hke9.onrender.com';

    let relaySocket = null;
    let relayIntent = null;
    let relayConnecting = false;
    let hostRoomId = null;
    let isHost = false;
    let hostId = null;
    let myId = null;
    const relayConnections = new Map();

    class RelayConnection {
      constructor(peerId, sendFn) {
        this.peer = peerId;
        this.open = true;
        this._sendFn = sendFn;
        this._handlers = { open: [], data: [], close: [], error: [] };
      }

      on(type, handler) {
        if (!this._handlers[type]) this._handlers[type] = [];
        this._handlers[type].push(handler);
      }

      emit(type, payload) {
        const list = this._handlers[type] || [];
        for (const fn of list) {
          try { fn(payload); } catch (e) { console.error(e); }
        }
      }

      send(payload) {
        if (!this.open) throw new Error('connection closed');
        this._sendFn(payload);
      }

      close() {
        if (!this.open) return;
        this.open = false;
        this.emit('close');
      }
    }

    function relayBaseUrl() {
      try {
        const v = localStorage.getItem('ninePokerRelayUrl');
        return (v && String(v).trim()) ? String(v).trim().replace(/\/+$/, '') : DEFAULT_RELAY_URL;
      } catch {
        return DEFAULT_RELAY_URL;
      }
    }

    function relayWsUrl() {
      const base = relayBaseUrl();
      if (!base) return '';
      if (base.startsWith('ws://') || base.startsWith('wss://')) return base;
      return base.replace(/^http/i, 'ws');
    }

    function relaySocketOpen() {
      return relaySocket && relaySocket.readyState === WebSocket.OPEN;
    }

    function closeRelaySocket() {
      if (relaySocket) {
        try { relaySocket.close(); } catch {}
      }
      relaySocket = null;
      relayConnecting = false;
    }

    function connectRelay(intent=null) {
      if (intent) relayIntent = intent;
      if (relaySocketOpen() || relayConnecting) return;
      const url = relayWsUrl();
      if (!url) {
        toast('Relay 伺服器網址未設定');
        return;
      }
      relayConnecting = true;
      relaySocket = new WebSocket(url);

      relaySocket.addEventListener('open', () => {
        relayConnecting = false;
        if (!relaySocketOpen()) return;
        if (!relayIntent) return;
        if (relayIntent.type === 'host') {
          relaySocket.send(JSON.stringify({ t: 'create-room', roomId: relayIntent.roomId, name: clientState.myName }));
        } else if (relayIntent.type === 'join') {
          relaySocket.send(JSON.stringify({ t: 'join-room', roomId: relayIntent.roomId, name: clientState.myName }));
        }
      });

      relaySocket.addEventListener('message', (event) => {
        let msg;
        try {
          msg = JSON.parse(event.data);
        } catch {
          return;
        }
        handleRelayMessage(msg);
      });

      relaySocket.addEventListener('close', () => {
        relayConnecting = false;
        setBadge(false, '已斷線');
        if (isHost) {
          for (const pid in hostState.players) {
            if (hostState.players[pid]?.conn) {
              try { hostState.players[pid].conn.close(); } catch {}
            }
          }
          relayConnections.clear();
        } else if (clientConn) {
          try { clientConn.close(); } catch {}
        }
        if (!isHost && clientState.roomId) {
          scheduleClientReconnect('relay-close');
        }
      });

      relaySocket.addEventListener('error', () => {
        relayConnecting = false;
        setBadge(false, '連線錯誤');
      });
    }

    function handleRelayMessage(msg) {
      if (!msg || typeof msg !== 'object') return;
      if (msg.t === 'error') {
        const message = msg.message || '連線錯誤';
        toast(message);
        log(`Relay error: ${message}`);
        return;
      }

      if (msg.t === 'hosted') {
        hostRoomId = msg.roomId;
        clientState.roomId = msg.roomId;
        myId = msg.id;
        hostId = msg.hostId;
        isHost = true;
        $('myPeerId').textContent = hostRoomId || msg.roomId;
        setRoleBadges();
        setBadge(true, '房間已建立');
        void finalizeHostCreation();
        return;
      }

      if (msg.t === 'joined') {
        clientState.roomId = msg.roomId;
        myId = msg.id;
        hostId = msg.hostId;
        isHost = false;
        $('myPeerId').textContent = clientState.roomId || msg.roomId;
        setRoleBadges();
        clientState.waitingForHost = !hostId;
        if (hostId) {
          clientConn = createRelayConn(hostId, false);
          wireConn(clientConn, false);
          clientConn.emit('open');
        } else {
          clientState.connected = false;
          clientState.joining = false;
          stopClientHeartbeat();
          setBadge(false, '等待房主上線');
        }
        return;
      }

      if (msg.t === 'client-joined') {
        if (!isHost) return;
        const pid = msg.id;
        if (!pid) return;
        if (!relayConnections.has(pid) && !hostState.players[pid]?.conn) {
          const conn = createRelayConn(pid, true);
          relayConnections.set(pid, conn);
          wireConn(conn, true);
          conn.emit('open');
        }
        return;
      }

      if (msg.t === 'client-left') {
        if (!isHost) return;
        const pid = msg.id;
        const conn = hostState.players[pid]?.conn || relayConnections.get(pid);
        if (conn) conn.close();
        relayConnections.delete(pid);
        return;
      }

      if (msg.t === 'host-left') {
        if (isHost) return;
        toast('房主已離線，等待重新連線');
        clientState.waitingForHost = true;
        hostId = null;
        if (clientConn) clientConn.close();
        clientState.connected = false;
        clientState.joining = false;
        stopClientHeartbeat();
        setBadge(false, '等待房主重連');
        return;
      }

      if (msg.t === 'host-reconnected') {
        if (isHost) return;
        hostId = msg.hostId;
        if (!hostId) return;
        if (msg.hostName) clientState.hostName = String(msg.hostName || '房主');
        clientState.waitingForHost = false;
        clientState.connected = false;
        clientState.joining = false;
        if (clientConn) { try { clientConn.close(); } catch {} }
        clientConn = createRelayConn(hostId, false);
        wireConn(clientConn, false);
        clientConn.emit('open');
        setBadge(false, '房主已重新連線');
        return;
      }

      if (msg.t === 'relay') {
        const fromId = msg.fromId;
        const payload = msg.payload;
        if (isHost) {
          const conn = hostState.players[fromId]?.conn || relayConnections.get(fromId);
          if (conn) conn.emit('data', payload);
        } else if (clientConn) {
          clientConn.emit('data', payload);
        }
      }
    }

    function createRelayConn(targetId, isHostSide) {
      return new RelayConnection(targetId, (payload) => {
        if (!relaySocketOpen()) throw new Error('Relay not connected');
        const to = isHostSide ? targetId : hostId;
        relaySocket.send(JSON.stringify({ t: 'relay', to, payload }));
      });
    }

    // ---- Keepalive / Reconnect (best effort; iOS may still suspend background tabs) ----
    const HEARTBEAT_MS = 8000;
    const HEARTBEAT_TIMEOUT_MS = 30000;
    const CLIENT_HEARTBEAT_ENABLED = false;
    let hostHeartbeatTimer = null;
    let clientHeartbeatTimer = null;
    let clientReconnectTimer = null;
    let clientReconnectAttempts = 0;

    function startHostHeartbeat() {
      if (hostHeartbeatTimer) return;
      hostHeartbeatTimer = setInterval(() => {
        if (!isHost) return;
        const now = Date.now();
        for (const pid in (hostState.players || {})) {
          const p = hostState.players[pid];
          // cleanup long-offline seats
          if ((!p?.conn || !p.conn.open) && p?.disconnectedAt && (now - p.disconnectedAt > 90000)) {
            delete hostState.players[pid];
            delete hostState.dealt[pid];
            delete hostState.submissions[pid];
            broadcastPlayers();
            renderPlayers();
            renderReadyList();
            continue;
          }
          if (!p?.conn || !p.conn.open) continue;
          const last = p.lastSeen || p.joinedAt || now;
          if (now - last > HEARTBEAT_TIMEOUT_MS) {
            try { p.conn.close(); } catch {}
            p.disconnectedAt = now;
            p.conn = null;
            continue;
          }
          try { send(p.conn, {t:'ping'}); } catch {}
        }
      }, HEARTBEAT_MS);
    }

    function stopHostHeartbeat() {
      if (hostHeartbeatTimer) {
        clearInterval(hostHeartbeatTimer);
        hostHeartbeatTimer = null;
      }
    }

    function startClientHeartbeat() {
      if (!CLIENT_HEARTBEAT_ENABLED) return;
      if (clientHeartbeatTimer) return;
      clientState.lastSeenFromHost = Date.now();
      clientHeartbeatTimer = setInterval(() => {
        if (isHost) return;
        if (!clientConn || !clientConn.open) return;
        const now = Date.now();
        if (clientState.lastSeenFromHost && (now - clientState.lastSeenFromHost > HEARTBEAT_TIMEOUT_MS)) {
          try { clientConn.close(); } catch {}
          scheduleClientReconnect('heartbeat-timeout');
          return;
        }
        try { send(clientConn, {t:'ping'}); } catch {}
      }, HEARTBEAT_MS);
    }

    function stopClientHeartbeat() {
      if (clientHeartbeatTimer) {
        clearInterval(clientHeartbeatTimer);
        clientHeartbeatTimer = null;
      }
    }

    function tryRelayReconnect() {
      if (relaySocketOpen() || relayConnecting) return;
      if (!relayIntent) return;
      connectRelay(relayIntent);
      setBadge(false, '重連中…');
    }

    function scheduleClientReconnect(reason='') {
      if (isHost) return;
      if (!clientState.roomId) return;
      if (clientState.joining) return;
      if (clientState.waitingForHost) return;
      if (document.hidden) return; // wait until visible

      if (clientReconnectTimer) return;
      clientReconnectAttempts = 0;

      const run = () => {
        if (isHost) return;
        if (!clientState.roomId) return;
        if (clientState.connected) { clientReconnectTimer = null; return; }

        clientReconnectAttempts += 1;
        const max = 6;
        setBadge(false, `重新連線中…（${clientReconnectAttempts}/${max}）`);

        tryRelayReconnect();

        try {
          if (clientConn) { try { clientConn.close(); } catch {} }
        } catch {}
        clientConn = null;

        connectRelay({ type: 'join', roomId: clientState.roomId });

        if (clientReconnectAttempts >= max) {
          clientReconnectTimer = null;
          toast('重新連線多次失敗，請手動離開後再加入');
          setBadge(false, '斷線');
          return;
        }

        clientReconnectTimer = setTimeout(() => {
          clientReconnectTimer = null;
          run();
        }, 2000 + clientReconnectAttempts * 500);
      };

      clientReconnectTimer = setTimeout(() => {
        clientReconnectTimer = null;
        run();
      }, 500);
    }

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) return;
      tryRelayReconnect();
      if (!isHost && !clientState.connected && clientState.roomId) {
        scheduleClientReconnect('resume');
      }
    });

    // Max players (including host)
    const MAX_PLAYERS_TOTAL = 6;

    // Host state
    const hostState = {
      settings: { roundsTotal: 5, bbMode: false },
      players: {}, // peerId -> {id,name,conn,joinedAt}
      seatOrder: [], // [hostId, ...playerIds] keeps seat positions stable (host-authoritative)
      round: 0,
      dealerId: null,
      dealt: {}, // peerId -> {all9}
      submissions: {}, // peerId -> {dealerCard, head, mid, tail, report}
      revealed: false,
      cumulative: {}, // peerId -> total
      dealerPick: null, // {controllerId, kind:'BJ'|'SJ', startedAt}
      dealerOverride: null, // dealerId chosen during dealer pick phase
    };

    // Client state
    const clientState = {
      myName: '玩家',
      hostName: '房主',
      roomId: null,
      connected: false,
      joining: false,
      players: {},
      seatOrder: [], // host-provided seat order (keeps positions stable)
      settings: { roundsTotal: 5, bbMode: false },
      round: 0,
      dealerId: null,
      cards9: [],
      dealerCard: null,
      arranged: { head:[null,null], mid:[null,null,null], tail:[null,null,null] },
      usedFromHand: new Set(),
      selectedCardKey: null, // legacy
      pick: null, // {kind:'hand'|'slot'|'dealer', ...}
      dealerTargetId: null, // legacy (no longer used)
      submitted: false,
      lastReveal: null,
      cumulative: {},
      pendingGameOver: null, // set when final round revealed; show after closing reveal modal
      chatUnread: false,
      bottomBarCollapsed: true,
      readyMap: {}, // {peerId: boolean} latest ready status from host
      waitingForHost: false,
    };

    // -------------------- Persisted room record (DAY/NIG) via GitHub repo + Cloudflare Worker --------------------
    // Goal: DAY/NIG rooms share a persistent scoreboard across devices.
    // Read: public JSON from GitHub repo (raw.githubusercontent.com)
    // Write: Cloudflare Worker (free) that holds a GitHub token and commits back to the repo.
    // Fallback: always cache to localStorage so the host device can recover even if worker fails.

    const PERSIST_ROOM_IDS = new Set(['DAY','MON']);

    // Where to store records in the GitHub repo
    const PERSIST_REPO = {
      owner: 'hketerrell',
      repo: 'HKE9',
      branch: 'main',
      dir: 'records',
    };

    // Cloudflare Worker endpoint (you will deploy this). Leave empty to disable cloud write.
    // You can also override at runtime via localStorage:
    //   localStorage.setItem('ninePokerPersistWorkerUrl', 'https://<your-worker>.workers.dev');
    // Optional shared secret (if your worker checks it):
    //   localStorage.setItem('ninePokerPersistSecret', '...');
    const DEFAULT_PERSIST_WORKER_URL = 'https://record.hke9.workers.dev';

    const persistState = {
      enabled: false,
      roomId: '',
      scoresByName: {}, // {name: number}
      // NOTE: We intentionally do NOT keep per-round history for DAY/NIG.
      // Only cumulative totals are stored.
    };

    function isPersistRoomId(id) {
      const s = String(id||'').trim().toUpperCase();
      return PERSIST_ROOM_IDS.has(s);
    }

    function persistKey(roomId, k) {
      return `ninePokerPersist_${String(roomId||'').toUpperCase()}_${k}`;
    }

    function persistWorkerUrl() {
      try {
        const v = localStorage.getItem('ninePokerPersistWorkerUrl');
        return (v && String(v).trim()) ? String(v).trim().replace(/\/+$/,'') : DEFAULT_PERSIST_WORKER_URL;
      } catch {
        return DEFAULT_PERSIST_WORKER_URL;
      }
    }

    function persistWorkerSecret() {
      try {
        return (localStorage.getItem('ninePokerPersistSecret') || '').trim();
      } catch {
        return '';
      }
    }

    function githubRawRecordUrl(roomId) {
      const rid = String(roomId||'').trim().toUpperCase();
      const {owner, repo, branch, dir} = PERSIST_REPO;
      // bust avoids CDN/browser cache
      return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${dir}/${encodeURIComponent(rid)}.json?bust=${Date.now()}`;
    }

    async function githubReadRecord(roomId) {
      const url = githubRawRecordUrl(roomId);
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (res.status === 404) return null;
        if (!res.ok) {
          const txt = await res.text().catch(()=> '');
          dlog(`Persist(GH): read failed (${res.status}) ${roomId}: ${txt.slice(0,140)}`);
          return null;
        }
        return await res.json();
      } catch (e) {
        dlog(`Persist(GH): read error ${roomId}: ${e?.message || e}`);
        return null;
      }
    }

    async function workerWriteRecord(roomId, record) {
      const base = persistWorkerUrl();
      if (!base) {
        dlog('Persist(Worker): worker URL not set (localStorage ninePokerPersistWorkerUrl). Saved locally only.');
        return false;
      }
      const secret = persistWorkerSecret();
      const url = base + '/save';
      try {
        dlog(`Persist(Worker): POST ${url} room=${String(roomId||'').trim().toUpperCase()}`);
      } catch {}
      try {
        const res = await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(secret ? {'X-Persist-Key': secret} : {}),
          },
          body: JSON.stringify({ roomId: String(roomId||'').trim().toUpperCase(), record }),
        });
        const txt = await res.text().catch(()=> '');
        if (!res.ok) {
          dlog(`Persist(Worker): save failed (${res.status}) ${roomId}: ${txt.slice(0,160)}`);
          return false;
        }
        dlog(`Persist(Worker): save OK ${roomId}`);
        return true;
      } catch (e) {
        dlog(`Persist(Worker): save error ${roomId}: ${e?.message || e}`);
        return false;
      }
    }

    function applyPersistScoreForPeer(pid, name) {
      const nm = String(name||'').trim();
      if (!nm) return;
      if (!persistState.enabled) return;
      const v = Number(persistState.scoresByName?.[nm] || 0);
      hostState.cumulative[pid] = v;
    }

    function refreshPersistScoresByNameFromCumulative() {
      if (!persistState.enabled) return;
      // IMPORTANT: merge into existing scores so absent players won't be erased.
      const map = { ...(persistState.scoresByName || {}) };
      // host
      if (hostId) {
        const hn = String(clientState.myName||'').trim();
        if (hn) map[hn] = Number(hostState.cumulative[hostId] || 0);
      }
      for (const pid in (hostState.players||{})) {
        const nm = String(hostState.players[pid]?.name||'').trim();
        if (!nm) continue;
        map[nm] = Number(hostState.cumulative[pid] || 0);
      }
      persistState.scoresByName = map;
    }

    function buildPersistRecordPayload() {
      const roomId = persistState.roomId;
      const now = new Date().toISOString();
      // Only cumulative totals (no per-round history)
      return {
        roomId,
        updatedAt: now,
        scoresByName: persistState.scoresByName || {},
      };
    }

    async function maybeLoadPersistRecordForHost(roomId) {
      const rid = String(roomId||'').trim().toUpperCase();
      if (!isPersistRoomId(rid)) return;
      persistState.enabled = true;
      persistState.roomId = rid;
      try { dlog(`Persist: enabled for ${rid} | worker=${persistWorkerUrl()}`); } catch {}

      // 1) local cache first
      try {
        const cached = localStorage.getItem(persistKey(rid,'record'));
        if (cached) {
          const json = JSON.parse(cached);
          if (json && typeof json === 'object') {
            persistState.scoresByName = json.scoresByName || {};
            dlog(`Persist(GH): loaded local cache for ${rid}`);
          }
        }
      } catch {}

      // 2) GitHub raw (public)
      const remote = await githubReadRecord(rid);
      if (remote && typeof remote === 'object') {
        persistState.scoresByName = remote.scoresByName || persistState.scoresByName || {};
        try { localStorage.setItem(persistKey(rid,'record'), JSON.stringify({scoresByName: persistState.scoresByName})); } catch {}
        dlog(`Persist(GH): loaded GitHub record for ${rid}`);
      } else {
        dlog(`Persist(GH): no GitHub record found for ${rid} (expected /${PERSIST_REPO.dir}/${rid}.json)`);
      }

      // Apply score to host now
      try { applyPersistScoreForPeer(hostId, clientState.myName); } catch {}
    }

    async function maybeSavePersistRecordAfterRound() {
      if (!isHost) return;
      if (!persistState.enabled) return;
      const rid = persistState.roomId;

      refreshPersistScoresByNameFromCumulative();
      const record = buildPersistRecordPayload();

      // Always cache locally (works offline)
      try {
        localStorage.setItem(persistKey(rid,'record'), JSON.stringify({scoresByName: record.scoresByName}));
        dlog(`Persist(Local): saved cache for ${rid} (names=${Object.keys(record.scoresByName||{}).length})`);
      } catch (e) {
        dlog(`Persist(Local): cache write failed for ${rid}: ${e?.message || e}`);
      }

      // Best-effort cloud save via worker
      await workerWriteRecord(rid, record);
    }

    function setRoleBadges() {
      const role = !relaySocketOpen() ? '未連線' : (isHost ? '房主' : '玩家');
      $('roleBadge').textContent = role;
      $('gameRoleBadge').textContent = role;

      const hostReady = !!(isHost && relaySocketOpen() && myId);

      // Lobby buttons
      $('btnApplyRounds').classList.toggle('hidden', !hostReady);
      $('btnStartGame').classList.toggle('hidden', !hostReady);
      $('btnCreateRoom').classList.toggle('hidden', hostReady);
      $('btnJoinRoom').classList.toggle('hidden', hostReady);

      // Game controls
      $('btnReveal').classList.toggle('hidden', !isHost);
      $('btnNextRound').classList.toggle('hidden', !isHost);
    }

  function resetAll() {
      // stop keepalive/reconnect timers
      try {
        persistState.enabled = false;
        persistState.roomId = '';
        persistState.fileId = null;
        persistState.scoresByName = {};
      } catch {}
      try { stopHostHeartbeat(); } catch {}
      try { stopClientHeartbeat(); } catch {}
      try {
        if (clientReconnectTimer) {
          clearTimeout(clientReconnectTimer);
          clientReconnectTimer = null;
        }
      } catch {}
      clientReconnectAttempts = 0;
      try { stopArrangeTimer(); } catch {}

      closeRelaySocket();
      relayIntent = null;
      isHost = false;
      hostId = null;
      hostRoomId = null;
      myId = null;
      relayConnections.clear();
      if (clientConn) {
        try { clientConn.close(); } catch {}
      }
      clientConn = null;
      clientState.roomId = null;
      clientState.connected = false;
      clientState.players = {};
      clientState.seatOrder = [];
      clientState.round = 0;
      clientState.dealerId = null;
      clientState.cards9 = [];
      clientState.dealerCard = null;
      clientState.arranged = { head:[null,null], mid:[null,null,null], tail:[null,null,null] };
      clientState.usedFromHand = new Set();
      clientState.selectedCardKey = null;
      clientState.pick = null;
      clientState.dealerTargetId = null;
      clientState.submitted = false;
      clientState.lastReveal = null;
      clientState.cumulative = {};
      clientState.bottomBarCollapsed = true;

      hostState.settings = { roundsTotal: 5 };
      hostState.players = {};
      hostState.seatOrder = [];
      hostState.round = 0;
      hostState.dealerId = null;
      hostState.dealt = {};
      hostState.submissions = {};
      hostState.revealed = false;
      hostState.cumulative = {};

      $('myPeerId').textContent = '—';
      $('btnCopyRoom').classList.add('hidden');
      $('btnCopyLink').classList.add('hidden');
      $('btnLeave').classList.add('hidden');
      $('btnOpenLastReveal').classList.add('hidden');
      $('scoreBody').innerHTML = '';
      $('myCumulative').textContent = '0';

      setBadge(false, '離線');
      setRoleBadges();
      renderPlayers();
      renderGameHeader();
      renderHand();
      renderSlots();
      renderReadyList();
      renderScores(null);
      closeRevealModal();
      updateBodyOverflow();
      updateChatUnread();
      log('已重置');
    }

    async function finalizeHostCreation() {
      // Init seat order and persisted record (DAY/NIG)
      try {
        const rid = String(hostRoomId || '').trim().toUpperCase();
        if (isPersistRoomId(rid)) {
          await maybeLoadPersistRecordForHost(rid);
        } else {
          persistState.enabled = false;
          persistState.roomId = '';
        }
      } catch {}

      // If we loaded persisted scores for host, keep it; otherwise reset.
      if (!persistState.enabled) {
        hostState.cumulative = {};
      } else {
        // ensure host cumulative exists
        try { applyPersistScoreForPeer(hostId, clientState.myName); } catch {}
      }
      clientState.cumulative = hostState.cumulative;

      try {
        if (!Array.isArray(hostState.seatOrder) || hostState.seatOrder.length === 0) hostState.seatOrder = [hostId];
        else if (hostState.seatOrder[0] !== hostId) hostState.seatOrder = [hostId, ...hostState.seatOrder.filter(x => x && x !== hostId)];
      } catch {}

      broadcastPlayers();
      renderPlayers();
      setRoleBadges();
      hostApplyRounds();
      updateMyCumulative();
      setBadge(true, '房間已建立');
      log('房間已建立，等待玩家加入');
      // show table immediately (waiting room)
      try { showPage('game'); renderTableSeats(); } catch {}

      $('btnLeave').classList.remove('hidden');
      $('btnCopyRoom').classList.remove('hidden');
      $('btnCopyLink').classList.remove('hidden');
    }


    function ensureName() {
      const nm = $('inpName').value.trim();
      clientState.myName = nm || '玩家';
      localStorage.setItem('ninePokerName', clientState.myName);
      $('inpName').value = clientState.myName;
    }

    // Default TURN (for cross-network/NAT)
    const DEFAULT_NET_CONFIG = {
      // 內建 TURN（預設不啟用；跨網絡連不上時再開）
      useTurn: false,
      turnUrl: 'turn:global.relay.metered.ca:80',
      turnUser: '68e493ec5be127af015d802b',
      turnPass: '/hFwmC/JAHDCqiic',
      relayOnly: false,
    };

    function loadNetConfig() {
      try {
        const raw = localStorage.getItem('ninePokerNetConfig');
        if (!raw) return { ...DEFAULT_NET_CONFIG };
        const parsed = JSON.parse(raw) || {};
        // Allow user to clear by saving empty strings
        return { ...DEFAULT_NET_CONFIG, ...parsed };
      } catch {
        return { ...DEFAULT_NET_CONFIG };
      }
    }

    function saveNetConfig(cfg) {
      localStorage.setItem('ninePokerNetConfig', JSON.stringify(cfg));
    }

    function applyNetConfigToUI() {
      const cfg = loadNetConfig();
      const use = $('chkUseTurn');
      const u = $('inpTurnUrl');
      const us = $('inpTurnUser');
      const pw = $('inpTurnPass');
      const ro = $('chkRelayOnly');
      if (use) use.checked = !!cfg.useTurn;
      if (u) u.value = cfg.turnUrl || '';
      if (us) us.value = cfg.turnUser || '';
      if (pw) pw.value = cfg.turnPass || '';
      if (ro) ro.checked = !!cfg.relayOnly;

      // Lobby quick toggle uses the same checkbox id; keep it in sync
      try {
        if ($('chkUseTurn')) $('chkUseTurn').checked = !!cfg.useTurn;
      } catch {}
    }

    function buildPeerOptions() {
      const cfg = loadNetConfig();

      const turnServers = (cfg.useTurn && cfg.turnUrl ? [
        {
          urls: String(cfg.turnUrl).trim(),
          username: String(cfg.turnUser || ''),
          credential: String(cfg.turnPass || ''),
        },
        {
          urls: String(cfg.turnUrl).trim().includes('transport=')
            ? String(cfg.turnUrl).trim()
            : (String(cfg.turnUrl).trim() + '?transport=tcp'),
          username: String(cfg.turnUser || ''),
          credential: String(cfg.turnPass || ''),
        },
      ] : []);

      const stunServers = [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:global.stun.twilio.com:3478' },
      ];

      const sanitizeIceServers = (servers) => {
        const out = [];
        for (const s of (servers || [])) {
          if (!s) continue;
          let urls = s.urls;
          if (typeof urls === 'string') urls = urls.trim();
          if (Array.isArray(urls)) urls = urls.map(x => String(x||'').trim()).filter(Boolean);
          if (typeof urls === 'string' && !urls) continue;
          if (Array.isArray(urls) && urls.length === 0) continue;
          const entry = { ...s, urls };
          out.push(entry);
        }
        return out;
      };

      // Safari/iOS 會因為 iceServers 裡任一條 URL 不被接受而直接丟 "Bad configuration parameters"。
      // 這裡先清理，再做一次「試建 RTCPeerConnection」的保守降級。
      let iceServers = sanitizeIceServers([...turnServers, ...stunServers]);

      try {
        // Probe
        const pc = new RTCPeerConnection({
          iceServers,
          iceTransportPolicy: cfg.relayOnly ? 'relay' : 'all',
        });
        pc.close();
      } catch (e) {
        // Fallback to minimal set
        iceServers = sanitizeIceServers([
          ...turnServers,
          { urls: 'stun:stun.l.google.com:19302' },
        ]);
      }

      const opts = {
        debug: 1,
        config: {
          iceServers,
          // If TURN not enabled, never force relay (would stall ICE)
          iceTransportPolicy: (cfg.useTurn && cfg.relayOnly) ? 'relay' : 'all',
        }
      };

      return opts;
    }

    // -------------------- TURN test --------------------
    function setTurnTestStatus(text, ok=null) {
      const eln = $('turnTestStatus');
      if (!eln) return;
      eln.textContent = text;
      eln.className = 'text-[11px] ' + (ok === true
        ? 'text-emerald-200'
        : (ok === false ? 'text-rose-200' : 'text-emerald-100/70'));
    }

    async function testTurnServer(cfgOverride=null) {
      const cfg = cfgOverride || loadNetConfig();
      const url = String(cfg.turnUrl || '').trim();
      if (!url) {
        setTurnTestStatus('TURN 測試：未填 TURN URL', false);
        toast('請先填入 TURN URL');
        return;
      }

      // Some providers require UDP/TCP variants; test both.
      const urls = [url];
      if (!url.includes('transport=')) urls.push(url + '?transport=tcp');

      setTurnTestStatus('TURN 測試：進行中…（正在收集 relay candidate）');

      const pc = new RTCPeerConnection({
        iceServers: [{
          urls,
          username: String(cfg.turnUser || ''),
          credential: String(cfg.turnPass || ''),
        }],
        iceTransportPolicy: 'relay',
      });

      let relayCandidate = null;
      let gatheredAny = false;

      try {
        // Create a data channel so ICE gathering starts.
        pc.createDataChannel('t');

        pc.onicecandidate = (ev) => {
          if (!ev.candidate) return;
          gatheredAny = true;
          const cand = ev.candidate.candidate || '';
          // Typical candidate line contains: "typ relay"
          if (cand.includes(' typ relay')) {
            relayCandidate = cand;
          }
        };

        // Kick off ICE.
        const offer = await pc.createOffer({offerToReceiveAudio:false, offerToReceiveVideo:false});
        await pc.setLocalDescription(offer);

        const startedAt = Date.now();
        const timeoutMs = 8000;
        while (Date.now() - startedAt < timeoutMs) {
          if (relayCandidate) break;
          if (pc.iceGatheringState === 'complete') break;
          await new Promise(r => setTimeout(r, 120));
        }

        if (relayCandidate) {
          setTurnTestStatus('TURN 測試：成功（已取得 relay candidate）', true);
          toast('TURN 可用：已取得 relay candidate');
          log('TURN test OK: ' + relayCandidate);
        } else {
          const state = pc.iceGatheringState;
          const hint = gatheredAny
            ? `未取得 relay candidate（iceGatheringState=${state}）。可能帳密/權限不正確或伺服器不允許中繼。`
            : `未收到任何 candidate（iceGatheringState=${state}）。可能 URL/port 被封鎖或伺服器無回應。`;
          setTurnTestStatus('TURN 測試：失敗（無 relay candidate）', false);
          toast('TURN 測試失敗：無 relay candidate');
          log('TURN test failed: ' + hint);
        }
      } catch (e) {
        const msg = e?.message || String(e);
        setTurnTestStatus('TURN 測試：錯誤（' + msg + '）', false);
        toast('TURN 測試錯誤：' + msg);
        log('TURN test error: ' + msg);
      } finally {
        try { pc.close(); } catch {}
      }
    }

    function wireConn(conn, incomingToHost=false) {
      conn.on('open', () => {
        if (isHost && incomingToHost) {
          log(`玩家連線進來：${conn.peer}`);
          // ensure host heartbeat is running
          startHostHeartbeat();
        }
        if (!isHost && !incomingToHost) {
          clientState.connected = true;
          clientState.joining = false;
          clientState.lastSeenFromHost = Date.now();
          setBadge(true, '已連線');
          log(`已連線到房主：${conn.peer}`);
          // start heartbeat after connected
          startClientHeartbeat();
          send(conn, {t:'join', name: clientState.myName});
        }
      });

      conn.on('data', (data) => {
        try {
          handleMessage(conn, data);
        } catch (e) {
          console.error(e);
          log('處理訊息失敗：' + (e.message || e));
        }
      });

      conn.on('error', (err) => {
        const type = err?.type || err?.message || String(err);
        if (isHost) {
          log(`Conn error from ${conn.peer}: ${type}`);
          try {
            const pid = conn.peer;
            if (hostState.players?.[pid]) hostState.players[pid].disconnectedAt = Date.now();
          } catch {}
        } else {
          const wasConnected = clientState.connected;
          clientState.connected = false;
          clientState.joining = false;
          stopClientHeartbeat();
          setBadge(false, '連線失敗');
          log(`連線錯誤：${type}`);
          if (wasConnected && !clientState.waitingForHost) {
            toast('連線中斷，嘗試自動重連…');
            scheduleClientReconnect('conn-error');
          } else {
            toast(type.includes('peer-unavailable')
              ? '房間不存在或房主尚未上線'
              : ('連線錯誤：' + type + '（可嘗試：離開/重置後再加入；跨網請測試/設定 TURN）'));
          }
        }
      });

      conn.on('close', () => {
        if (isHost) {
          const pid = conn.peer;
          if (hostState.players[pid]) {
            log(`玩家離線：${hostState.players[pid].name} (${pid})`);
            // do not immediately remove; mark offline to allow quick resume
            hostState.players[pid].conn = null;
            hostState.players[pid].disconnectedAt = Date.now();
            broadcastPlayers();
            renderPlayers();
            renderReadyList();
          }
        } else {
          const wasJoining = clientState.joining;
          const wasConnected = clientState.connected;
          clientState.connected = false;
          clientState.joining = false;
          stopClientHeartbeat();
          setBadge(false, '已斷線');
          log('與房主連線已關閉');
          if (wasJoining) {
            toast('連線被關閉：可能房主不在線/房號錯誤，或 ICE 無法打通（跨網/NAT 請測試 TURN）');
          } else if (wasConnected && !clientState.waitingForHost) {
            toast('連線中斷，嘗試自動重連…');
            scheduleClientReconnect('conn-close');
          }
        }
      });
    }

    function send(conn, obj) {
      conn.send({ ...obj, _ts: Date.now() });
    }

    function broadcast(obj) {
      for (const pid in hostState.players) {
        try { hostState.players[pid].conn.send({ ...obj, _ts: Date.now() }); } catch {}
      }
    }

    function broadcastPlayers() {
      const list = Object.values(hostState.players).map(p => ({id:p.id, name:p.name}));
      broadcast({t:'players', list, hostId, hostName: clientState.myName || '房主', seatOrder: hostState.seatOrder});
    }

    function handleMessage(conn, msg) {
      if (!msg || typeof msg !== 'object') return;

      // ---- keepalive ----
      if (msg.t === 'ping') {
        try { send(conn, {t:'pong'}); } catch {}
        if (isHost) {
          const pid = conn.peer;
          if (hostState.players?.[pid]) hostState.players[pid].lastSeen = Date.now();
        } else {
          clientState.lastSeenFromHost = Date.now();
        }
        return;
      }
      if (msg.t === 'pong') {
        if (isHost) {
          const pid = conn.peer;
          if (hostState.players?.[pid]) hostState.players[pid].lastSeen = Date.now();
        } else {
          clientState.lastSeenFromHost = Date.now();
        }
        return;
      }

      if (isHost) {
        handleAsHost(conn, msg);
      } else {
        handleAsClient(conn, msg);
      }
    }

    function handleAsHost(conn, msg) {
      if (msg.t === 'join') {
        const pid = conn.peer;
        try { relayConnections.delete(pid); } catch {}

        // room full check (host + players <= MAX_PLAYERS_TOTAL)
        const currentTotal = 1 + Object.keys(hostState.players).length;
        if (currentTotal >= MAX_PLAYERS_TOTAL) {
          try { send(conn, {t:'error', message:`房間已滿（最多 ${MAX_PLAYERS_TOTAL} 人）`}); } catch {}
          try { conn.close(); } catch {}
          log(`拒絕加入（房間已滿）：${pid}`);
          return;
        }

        const name = String(msg.name || '玩家').slice(0,20);
        const roundInProgress = (hostState.round > 0) && !hostState.revealed;

        // 1) exact peerId re-join
        let existed = hostState.players[pid] || null;

        // 2) name-based reconnect: if someone disconnected and comes back with a new peerId but same name,
        // migrate that seat/state to the new pid.
        let migratedFromId = null;
        if (!existed) {
          const norm = (s) => String(s||'').trim();
          const targetName = norm(name);
          const now = Date.now();
          const candidates = Object.values(hostState.players || {})
            .filter(p => {
              if (!p || norm(p.name) !== targetName) return false;
              if (!p.conn || !p.conn.open) return true;
              const lastSeen = p.lastSeen || p.joinedAt || 0;
              return (now - lastSeen) > HEARTBEAT_TIMEOUT_MS;
            })
            .sort((a,b) => Number(a.disconnectedAt||0) - Number(b.disconnectedAt||0));
          if (candidates.length) {
            const previous = candidates[0];
            migratedFromId = previous.id;
            try {
              if (previous.conn && previous.conn.open) {
                previous.conn.close();
              }
            } catch {}
            // Move state: cumulative/dealt/submissions + seatOrder
            try {
              if (hostState.cumulative[migratedFromId] !== undefined) {
                hostState.cumulative[pid] = hostState.cumulative[migratedFromId];
                delete hostState.cumulative[migratedFromId];
              }
              if (hostState.dealt[migratedFromId]) {
                hostState.dealt[pid] = hostState.dealt[migratedFromId];
                delete hostState.dealt[migratedFromId];
              }
              if (hostState.submissions[migratedFromId]) {
                hostState.submissions[pid] = hostState.submissions[migratedFromId];
                delete hostState.submissions[migratedFromId];
              }
              if (hostState.seatOrder && hostState.seatOrder.length) {
                hostState.seatOrder = hostState.seatOrder.map(x => x === migratedFromId ? pid : x);
              }
              delete hostState.players[migratedFromId];
            } catch {}
            existed = null;
            log(`名稱重連：${name} (${migratedFromId} -> ${pid})`);
          }
        }

        // Block truly NEW players from entering while a round is in progress.
        if (!existed && !migratedFromId && roundInProgress) {
          try { send(conn, {t:'error', message:'本局進行中，請下一局前再加入（可等房主按「下一局」後再入座）'}); } catch {}
          try { conn.close(); } catch {}
          log(`拒絕加入（本局進行中）：${pid}`);
          return;
        }

        hostState.players[pid] = {
          id: pid,
          name,
          conn,
          joinedAt: existed?.joinedAt || Date.now(),
          lastSeen: Date.now(),
          disconnectedAt: null,
        };

        // If this is a persisted room (DAY/NIG), apply cumulative by player name
        try {
          if (persistState.enabled) {
            applyPersistScoreForPeer(pid, name);
          }
        } catch {}

        // Maintain seat order (host + join order). Keep host first.
        try {
          if (!Array.isArray(hostState.seatOrder) || hostState.seatOrder.length === 0) hostState.seatOrder = [hostId];
          if (!hostState.seatOrder.includes(pid)) hostState.seatOrder.push(pid);
          // Always ensure hostId at index 0
          hostState.seatOrder = [hostId, ...hostState.seatOrder.filter(x => x && x !== hostId)];
        } catch {}

        renderPlayers();
        send(conn, {
          t:'welcome',
          hostId,
          hostName: (clientState.myName || '房主'),
          settings: hostState.settings,
          me: {id: pid},
          cumulative: hostState.cumulative,
          seatOrder: hostState.seatOrder,
        });

        // broadcast updated player list + seat order
        broadcastPlayers();
        broadcast({t:'settings', settings: hostState.settings});
        broadcast({t:'seatOrder', seatOrder: hostState.seatOrder});

        log(`${(existed || migratedFromId) ? '玩家重連' : '玩家加入'}：${name} (${pid})`);

        // If game already started, send a start snapshot so the client doesn't stay in "請房主開始" state.
        try {
          if (hostState.round > 0) {
            send(conn, {t:'start', round: hostState.round, settings: hostState.settings, cumulative: hostState.cumulative});
          }
        } catch {}

        // If this is a re-join during an active round, re-send their current hand so they can continue.
        try {
          if ((existed || migratedFromId) && roundInProgress && hostState.dealt?.[pid]?.all9) {
            const ready = readyMapForBroadcast();
            send(conn, {t:'deal', round: hostState.round, cards9: hostState.dealt[pid].all9, ready, resume: true});
            send(conn, {t:'ready', ready});
            log(`已補發本局手牌給重連玩家：${name} (${pid})`);
          }
        } catch {}

        // If game already finished this round but not started next, tell the player to wait.
        try {
          if (!roundInProgress && hostState.round > 0 && hostState.revealed && !hostState.dealt?.[pid]) {
            send(conn, {t:'waitNextRound', round: hostState.round});
          }
        } catch {}

        // start heartbeat as soon as we have at least one player
        startHostHeartbeat();
        return;
      }

      if (msg.t === 'submit') {
        const pid = conn.peer;
        if (!hostState.dealt[pid]) return;

        const sub = {
          dealerCard: msg.dealerCard,
          head: msg.head,
          mid: msg.mid,
          tail: msg.tail,
          report: msg.report || 'none',
        };

        const ok = validateSubmissionAgainstDeal(pid, sub);
        if (!ok.ok) {
          send(conn, {t:'error', message: ok.msg});
          log(`拒絕提交（${hostState.players[pid]?.name || pid}）：${ok.msg}`);
          return;
        }

        hostState.submissions[pid] = sub;
        log(`收到提交：${hostState.players[pid]?.name || pid}`);
        const rmap = readyMapForBroadcast();
        broadcast({t:'ready', ready: rmap});
        // update host local ready map for seat tick
        try { clientState.readyMap = rmap; } catch {}
        try { renderTableSeats(); } catch {}
        renderReadyList();
        updateMidActionButton();

        if (allSubmitted()) {
          // If any dealerCard is Joker, start pre-reveal dealer-pick flow.
          const controller = findDealerPickController(hostState.submissions);
          if (controller) {
            hostState.dealerPick = { ...controller, round: hostState.round, startedAt: Date.now() };
            hostState.dealerOverride = null;
            const ctx = {
              t: 'dealerPickStart',
              round: hostState.round,
              controllerId: controller.controllerId,
              kind: controller.kind,
              submissions: sanitizeSubsForBroadcast(),
              players: allPlayersForBroadcast(),
            };
            // Send only to controller (it might be host)
            if (controller.controllerId === hostId) {
              openDealerPickPreModal({
                round: ctx.round,
                kind: ctx.kind,
                controllerId: ctx.controllerId,
                submissions: ctx.submissions,
                players: ctx.players,
                currentDealerId: hostId,
              });
              toast('你持有鬼牌：請在結算前指定莊家');
            } else {
              const p = hostState.players[controller.controllerId];
              if (p?.conn) send(p.conn, ctx);
              toast('等待鬼牌玩家指定莊家…');
              log(`等待 ${hostState.players[controller.controllerId]?.name || controller.controllerId} 指定莊家`);
            }
            return;
          }

          // No dealer-pick needed, reveal immediately.
          revealRound();
        }
        return;
      }

      if (msg.t === 'dealerPickChoice') {
        // controller sends {round, kind, dealerId}
        const pick = msg.pick || {};
        const expected = hostState.dealerPick;
        if (!expected) {
          send(conn, {t:'error', message:'目前沒有需要指定莊家的局'});
          return;
        }
        if (pick.round !== expected.round) {
          send(conn, {t:'error', message:'指定莊家局數不符'});
          return;
        }
        if (conn.peer !== expected.controllerId) {
          send(conn, {t:'error', message:'你不是本局指定莊家的控制者'});
          return;
        }

        const dealerId = String(pick.dealerId || '');
        const ids = [hostId, ...Object.keys(hostState.players)];
        if (!ids.includes(dealerId)) {
          send(conn, {t:'error', message:'指定的莊家不在房間內'});
          return;
        }

        hostState.dealerOverride = dealerId;
        hostState.dealerPick = null;
        broadcast({t:'dealerPickFinal', round: pick.round, dealerId});
        toast('已收到莊家指定，開始結算');
        revealRound();
        // ensure host action button updates even in dealer-pick flow
        try { updateMidActionButton(); } catch {}
        return;
      }

      if (msg.t === 'restartRequest') {
        // only host can restart; this is a hint from players
        const from = hostState.players[conn.peer]?.name || conn.peer;
        log(`收到再來一局請求：${from}`);
        toast(`收到 ${from} 的再來一局請求`);
        return;
      }
      
      // 房主處理踢人指令
      if (msg.t === 'kick') {
        const targetId = msg.targetId;
        // 不能踢自己，且目標必須存在
        if (!targetId || targetId === hostId || !hostState.players[targetId]) return;

        const pName = hostState.players[targetId].name;
        
        // 1. 嘗試通知被踢的玩家 (如果還連線)
        if (hostState.players[targetId].conn) {
            try { send(hostState.players[targetId].conn, {t:'kicked'}); } catch {}
            try { hostState.players[targetId].conn.close(); } catch {}
        }

        // 2. 從資料中移除
        delete hostState.players[targetId];
        delete hostState.dealt[targetId];
        delete hostState.submissions[targetId];
        //delete hostState.cumulative[targetId]; // 選擇性：是否連分數一起刪除，通常踢人就全刪
        
        // 3. 從座位表移除
        if (hostState.seatOrder) {
            hostState.seatOrder = hostState.seatOrder.filter(x => x !== targetId);
        }

        // 4. 更新給所有人
        broadcastPlayers();
        renderPlayers();
        renderReadyList();
        try { renderTableSeats(); } catch {}

        log(`房主已踢出玩家：${pName}`);
        toast(`已踢出 ${pName}`);
        return;
      }

      if (msg.t === 'chat') {
        const fromId = conn.peer;
        const fromName = hostState.players[fromId]?.name || fromId;

        // Normalise
        const kind = msg.kind || 'text';
        const text = kind === 'text' ? String(msg.text||'').slice(0,200) : '';
        const url = kind === 'sticker' ? String(msg.url||'').slice(0,500) : '';

        // broadcast to all (including sender)
        broadcast({t:'chat', kind, from: fromName, fromId, text, url});

        // local: keep chat record + danmaku for everything
        if (kind === 'sticker' && url) {
          glog(`${fromName}：`, {chat:true, kind:'sticker', url});
          spawnDanmaku({kind:'sticker', url}, fromName);
        } else {
          glog(`${fromName}：${text}`, {chat:true});
          spawnDanmaku({kind:'text', text}, fromName);
        }
        return;
      }

      if (msg.t === 'danmaku') {
        const fromId = conn.peer;
        const fromName = hostState.players[fromId]?.name || fromId;
        const kind = msg.kind || 'text';
        const text = kind === 'text' ? String(msg.text||'').slice(0,200) : '';
        const url = kind === 'sticker' ? String(msg.url||'').slice(0,500) : '';

        // broadcast to all (including sender)
        broadcast({t:'danmaku', kind, from: fromName, fromId, text, url});

        // show on host immediately
        if (kind === 'sticker' && url) spawnDanmaku({kind:'sticker', url}, fromName);
        else spawnDanmaku({kind:'text', text}, fromName);
        return;
      }

      if (msg.t === 'poop') {
        const fromId = conn.peer;
        const fromName = hostState.players[fromId]?.name || fromId;
        const targetId = String(msg.targetId || '');
        if (!targetId) return;
        // broadcast to all (including sender)
        broadcast({t:'poop', from: fromName, fromId, targetId});
        // show on host immediately (throw)
        spawnPoopThrow(fromId, targetId);
        return;
      }
    }

    function handleAsClient(conn, msg) {
      // 被踢出的處理
      if (msg.t === 'kicked') {
        alert('你已被房主踢出房間。');
        resetAll(); // 重置狀態
        showPage('lobby'); // 回到大廳
        return;
      }
      
      if (msg.t === 'welcome') {
        hostId = msg.hostId;
        clientState.hostName = String(msg.hostName || '房主');
        if (Array.isArray(msg.seatOrder)) clientState.seatOrder = msg.seatOrder.slice();
        clientState.settings = msg.settings || clientState.settings;
        clientState.cumulative = msg.cumulative || clientState.cumulative || {};
        $('inpRounds').value = clientState.settings.roundsTotal;
        try { $('chkBBMode').checked = !!clientState.settings.bbMode; } catch {}

        // stop any pending reconnect loop
        try {
          if (clientReconnectTimer) {
            clearTimeout(clientReconnectTimer);
            clientReconnectTimer = null;
          }
        } catch {}
        clientReconnectAttempts = 0;

        setRoleBadges();
        renderPlayers();
        try { showPage('game'); renderTableSeats(); } catch {}
        updateMyCumulative();
        log(`加入成功。房主：${hostId}`);
        return;
      }

      if (msg.t === 'players') {
        clientState.players = {};
        for (const p of (msg.list||[])) clientState.players[p.id] = p;
        hostId = msg.hostId || hostId;
        if (msg.hostName) clientState.hostName = String(msg.hostName || '房主');
        if (Array.isArray(msg.seatOrder)) clientState.seatOrder = msg.seatOrder.slice();
        renderPlayers();
        try { renderTableSeats(); } catch {}
        return;
      }

      if (msg.t === 'seatOrder') {
        if (Array.isArray(msg.seatOrder)) {
          clientState.seatOrder = msg.seatOrder.slice();
          try { renderLobbySeats(); } catch {}
          try { renderTableSeats(); } catch {}
        }
        return;
      }

      if (msg.t === 'settings') {
        clientState.settings = msg.settings || clientState.settings;
        $('inpRounds').value = clientState.settings.roundsTotal;
        try { $('chkBBMode').checked = !!clientState.settings.bbMode; } catch {}
        log(`設定更新：局數 ${clientState.settings.roundsTotal}｜BB模式 ${clientState.settings.bbMode ? 'ON' : 'OFF'}`);
        return;
      }

      if (msg.t === 'start') {
        showPage('game');
        $('btnGoLobby').classList.remove('hidden');
        clientState.round = msg.round;
        clientState.settings = msg.settings || clientState.settings;
        clientState.cumulative = msg.cumulative || clientState.cumulative || {};
        $('gameRoomId').textContent = clientState.roomId || '—';
        $('gameRoundInfo').textContent = `${clientState.round} / ${clientState.settings.roundsTotal}`;
        // chat log hides system messages; use toast instead
        toast(`遊戲開始（共 ${clientState.settings.roundsTotal} 局）`);
        updateMyCumulative();
        try { renderTableSeats(); } catch {}
        return;
      }

      if (msg.t === 'deal') {
        clientState.round = msg.round;
        updateMidActionButton();
        // ready map for seat tick
        try { clientState.readyMap = msg.ready || {}; } catch {}
        clientState.dealerId = null;
        clientState.cards9 = msg.cards9 || [];
        clientState.dealerCard = null;
        clientState.arranged = { head:[null,null], mid:[null,null,null], tail:[null,null,null] };
        clientState.usedFromHand = new Set();
        clientState.selectedCardKey = null;
        clientState.pick = null;
        clientState.dealerTargetId = null;
        clientState.submitted = false;
        try { $('selReport').value = 'none'; } catch {}
        $('submitStatus').textContent = '尚未提交';
        $('submitStatus').className = 'text-xs text-emerald-50/80';
        $('scoreBody').innerHTML = '';
        $('btnOpenLastReveal').classList.add('hidden');

        // Auto open Arrange when a new hand is dealt
        closeModalsForNewHand();

        renderGameHeader();
        renderHand();
        renderSlots();
        renderReadyList(msg.ready || null);
        try { renderTableSeats(); } catch {}

        // Let players know a new round started, then open Arrange
        toast(`第 ${clientState.round} 局已開始，請排牌`);
        openArrangeModal();
        startArrangeTimer();
        return;
      }

      if (msg.t === 'ready') {
        try { clientState.readyMap = msg.ready || {}; } catch {}
        try { renderTableSeats(); } catch {}
        renderReadyList(msg.ready);
        return;
      }

      if (msg.t === 'dealerPickStart') {
        // Only controller should see the pre-reveal dealer pick modal
        const controllerId = String(msg.controllerId || '');
        if (controllerId !== myId) {
          glog('等待鬼牌玩家指定莊家…');
          return;
        }
        openDealerPickPreModal({
          round: msg.round,
          kind: msg.kind,
          controllerId,
          submissions: msg.submissions || {},
          players: msg.players || [],
          currentDealerId: myId,
        });
        glog('你持有鬼牌：請在結算前指定莊家');
        return;
      }

      if (msg.t === 'dealerPickFinal') {
        // informational
        glog('莊家已指定：' + getNameById(msg.dealerId));
        return;
      }

      if (msg.t === 'reveal') {
        clientState.lastReveal = msg;
        updateMidActionButton();
        try {
          const rm = {};
          for (const p of (msg.players||[])) rm[p.id] = !!msg.submissions?.[p.id];
          clientState.readyMap = rm;
        } catch {}
        try { renderTableSeats(); } catch {}
        clientState.dealerId = msg.dealerId;
        clientState.cumulative = msg.cumulative || clientState.cumulative || {};
        renderGameHeader();
        renderScores(msg);
        updateMyCumulative();
        try { renderTableSeats(); playRevealOnTable(msg); } catch {}

        // Do NOT auto-open detailed reveal modal; show it only when user taps "本局結算"
        $('btnOpenLastReveal').classList.remove('hidden');

        // If this is the final round, delay gameOver modal until user checks/finishes this round
        const roundsTotal = clientState.settings.roundsTotal;
        if (Number(msg.round) >= Number(roundsTotal)) {
          clientState.pendingGameOver = {
            roomId: clientState.roomId,
            players: msg.players || [],
            cumulative: clientState.cumulative,
          };
          // Auto-open final summary after a short delay (unless user opens the round detail modal)
          setTimeout(() => {
            if (!clientState.pendingGameOver) return;
            const revealOpen = !$('revealModal').classList.contains('hidden');
            const overOpen = !$('gameOverModal').classList.contains('hidden');
            if (revealOpen || overOpen) return;
            const payload = clientState.pendingGameOver;
            clientState.pendingGameOver = null;
            openGameOverModal(payload);
          }, 1600);
        }
        return;
      }

      if (msg.t === 'nextRound') {
        clientState.lastReveal = null;
        updateMidActionButton();
        clientState.dealerId = null;
        try { clientState.readyMap = {}; } catch {}
        try { renderTableSeats(); } catch {}
        $('scoreBody').innerHTML = '';
        renderGameHeader();
        $('btnOpenLastReveal').classList.add('hidden');
        glog('準備下一局…');
        return;
      }

      if (msg.t === 'waitNextRound') {
        // Informational: joined between rounds; wait for next deal.
        const r = Number(msg.round || 0);
        toast(r ? `已加入房間，請等待房主開始第 ${r+1} 局` : '已加入房間，請等待房主開始下一局');
        try { showPage('game'); renderTableSeats(); } catch {}
        return;
      }

      if (msg.t === 'gameOver') {
        // show summary modal (delay if reveal/status modal is open)
        clientState.cumulative = msg.cumulative || clientState.cumulative || {};
        const payload = {
          roomId: clientState.roomId,
          players: msg.players || [],
          cumulative: clientState.cumulative,
        };

        const revealOpen = !$('revealModal').classList.contains('hidden');
        if (revealOpen) {
          clientState.pendingGameOver = payload;
          glog('遊戲已完結（關閉本局結算後顯示總結）');
        } else {
          openGameOverModal(payload);
          glog('遊戲已完結');
        }
        return;
      }

      if (msg.t === 'restart') {
        // reset per-game states, keep connection
        clientState.lastReveal = null;
        clientState.dealerId = null;
        clientState.round = 0;
        clientState.cumulative = msg.cumulative || {};
        $('scoreBody').innerHTML = '';
        $('btnOpenLastReveal').classList.add('hidden');
        closeRevealModal();
        closeGameOverModal();
        renderGameHeader();
        updateMyCumulative();
        glog('房主已重開新一局（從第 1 局開始）');
        return;
      }

      if (msg.t === 'chat') {
        // de-dup: if this is my own message echoed back, skip (already appended locally)
        if (msg.fromId && msg.fromId === myId) return;

        const kind = msg.kind || 'text';
        if (kind === 'sticker' && msg.url) {
          glog(`${msg.from}：`, {chat:true, kind:'sticker', url: String(msg.url)});
          spawnDanmaku({kind:'sticker', url: String(msg.url)}, String(msg.from||''));
        } else {
          glog(`${msg.from}：${msg.text}`, {chat:true});
          spawnDanmaku({kind:'text', text: String(msg.text||'')}, String(msg.from||''));
        }
        return;
      }

      if (msg.t === 'danmaku') {
        // de-dup: if this is my own danmaku echoed back, skip (already shown locally)
        if (msg.fromId && msg.fromId === myId) return;

        const kind = msg.kind || 'text';
        if (kind === 'sticker' && msg.url) {
          spawnDanmaku({kind:'sticker', url: String(msg.url||'')}, String(msg.from||''));
        } else {
          spawnDanmaku({kind:'text', text: String(msg.text||'')}, String(msg.from||''));
        }
        return;
      }

      if (msg.t === 'poop') {
        // de-dup: if this is my own poop echoed back, skip (already shown locally)
        if (msg.fromId && msg.fromId === myId) return;
        spawnPoopThrow(String(msg.fromId||''), String(msg.targetId||''));
        return;
      }

      if (msg.t === 'error') {
        const m = msg.message || '發生錯誤';
        toast(m);
        // If join-related error, stop joining state so UI won't stay "連線中"
        if (clientState.joining) {
          clientState.joining = false;
          if (!clientState.connected) setBadge(false, '錯誤');
        }
      }
    }
    function isPlayerConnected(pid) {
      const p = hostState.players?.[pid];
      return !!(p?.conn && p.conn.open);
    }

    function roundPlayerIds() {
      const ids = [hostId];
      for (const pid in hostState.players) {
        if (isPlayerConnected(pid) || hostState.submissions?.[pid]) ids.push(pid);
      }
      return ids;
    }

    function activePlayerIdsForDeal() {
      const ids = [hostId];
      for (const pid in hostState.players) {
        if (isPlayerConnected(pid)) ids.push(pid);
      }
      return ids;
    }

    function readyMapForBroadcast() {
      const out = {};
      for (const id of roundPlayerIds()) out[id] = !!hostState.submissions[id];
      return out;
    }

    function allSubmitted() {
      const ids = roundPlayerIds();
      return ids.every(id => !!hostState.submissions[id]);
    }

    // -------------------- Host validation & game logic --------------------
    function normalizeCard(c) {
      if (!c || typeof c !== 'object') return null;
      if (c.s === 'J') {
        if (c.j !== 'BJ' && c.j !== 'SJ') return null;
        return {s:'J', j:c.j, r: c.j==='BJ'?16:15};
      }
      if (!SUITS.includes(c.s)) return null;
      const r = Number(c.r);
      if (!Number.isInteger(r) || r < 2 || r > 14) return null;
      return {r, s:c.s};
    }

    function validateSubmissionAgainstDeal(pid, sub) {
      const dealt = hostState.dealt[pid]?.all9;
      if (!dealt || dealt.length !== 9) return {ok:false, msg:'尚未發牌'};
      const dealtKeys = new Set(dealt.map(cardKey));

      const dealerCard = normalizeCard(sub.dealerCard);
      const head = (sub.head||[]).map(normalizeCard);
      const mid = (sub.mid||[]).map(normalizeCard);
      const tail = (sub.tail||[]).map(normalizeCard);

      if (!dealerCard) return {ok:false, msg:'請選擇選莊牌'};
      if (head.length !== 2 || mid.length !== 3 || tail.length !== 3) return {ok:false, msg:'頭/中/尾墩張數必須為：2 / 3 / 3'};
      if (head.some(x=>!x) || mid.some(x=>!x) || tail.some(x=>!x)) return {ok:false, msg:'牌資料不完整'};

      const used = [dealerCard, ...head, ...mid, ...tail].map(cardKey);
      const uniq = new Set(used);
      if (uniq.size !== 9) return {ok:false, msg:'牌重複（選莊/墩牌不可重複）'};
      for (const k of uniq) {
        if (!dealtKeys.has(k)) return {ok:false, msg:'提交的牌不在你的手牌中'};
      }

      // 允許「擺烏龍」提交（結算時會依規則處理）

      return {ok:true};
    }

    function hostApplyRounds() {
      let v = Number($('inpRounds').value);
      if (!Number.isFinite(v) || v < 5) v = 5;
      v = Math.round(v/5)*5;
      if (v < 5) v = 5;
      $('inpRounds').value = v;

      // BB mode (disable arrange timer)
      const bb = !!$('chkBBMode')?.checked;
      hostState.settings.roundsTotal = v;
      hostState.settings.bbMode = bb;
      try { localStorage.setItem('ninePokerBBMode', bb ? '1' : '0'); } catch {}

      broadcast({t:'settings', settings: hostState.settings});
      log(`房主設定：局數 ${v}｜BB模式 ${bb ? 'ON' : 'OFF'}`);
    }

    function startGame() {
      if (!isHost) return;
      if (!relaySocketOpen() || !myId) return;
      if (Object.keys(hostState.players).length < 1) {
        toast('至少需要 2 人（含房主）才能開始');
        return;
      }
      hostState.round = 0;

      // IMPORTANT: for DAY/NIG persistent rooms, do NOT reset cumulative.
      if (!persistState.enabled) {
        hostState.cumulative = {};
        clientState.cumulative = {};
      } else {
        clientState.cumulative = hostState.cumulative;
      }

      broadcast({t:'start', round: 1, settings: hostState.settings, cumulative: hostState.cumulative});
      showPage('game');
      $('gameRoomId').textContent = hostRoomId || clientState.roomId || myId;
      renderGameHeader();
      try { renderTableSeats(); } catch {}
      log(`房主開始遊戲：共 ${hostState.settings.roundsTotal} 局`);
      updateMyCumulative();
      nextRound();
    }

    function nextRound() {
      if (!isHost) return;
      hostState.round += 1;
      hostState.revealed = false;
      updateMidActionButton();
      try { renderTableSeats(); } catch {}
      hostState.dealt = {};
      hostState.submissions = {};
      hostState.dealerId = null;
      hostState.dealerPick = null;
      hostState.dealerOverride = null;
      // clear ready map for new round (seat tick)
      try { clientState.readyMap = readyMapForBroadcast(); } catch {}
      try { renderTableSeats(); } catch {}

      if (hostState.round > hostState.settings.roundsTotal) {
        broadcast({t:'error', message:'遊戲已結束'});
        glog('遊戲已結束');
        toast('遊戲已結束');
        return;
      }

      broadcast({t:'nextRound', round: hostState.round});
      // clear last reveal (host local)
      clientState.lastReveal = null;
      glog(`第 ${hostState.round} 局：發牌中…`);

      const ids = activePlayerIdsForDeal();
      const deck = shuffle(makeDeck54());
      const need = ids.length * 9;
      if (deck.length < need) {
        toast('人數過多，牌不夠（此原型為單副 54 張）');
        return;
      }

      let idx = 0;
      for (const id of ids) {
        const all9 = deck.slice(idx, idx+9);
        idx += 9;
        hostState.dealt[id] = { all9 };
      }

      const ready = readyMapForBroadcast();
      for (const pid of ids) {
        if (pid === hostId) continue;
        const p = hostState.players[pid];
        if (!p?.conn) continue;
        send(p.conn, {
          t:'deal',
          round: hostState.round,
          cards9: hostState.dealt[pid].all9,
          ready,
        });
      }

      // host as client
      clientState.round = hostState.round;
      clientState.dealerId = null;
      clientState.cards9 = hostState.dealt[hostId].all9;
      clientState.dealerCard = null;
      clientState.arranged = { head:[null,null], mid:[null,null,null], tail:[null,null,null] };
      clientState.usedFromHand = new Set();
      clientState.selectedCardKey = null;
      clientState.pick = null;
      clientState.dealerTargetId = null;
      clientState.pendingGameOver = null;
      clientState.submitted = false;
      try { $('selReport').value = 'none'; } catch {}
      $('submitStatus').textContent = '尚未提交';
      $('submitStatus').className = 'text-xs text-emerald-50/80';
      $('scoreBody').innerHTML = '';
      $('btnOpenLastReveal').classList.add('hidden');

      renderPlayers();
      renderGameHeader();
      renderHand();
      renderSlots();
      renderReadyList(ready);
      updateMyCumulative();

      // Host: auto open Arrange on each new round
      closeModalsForNewHand();
      toast(`第 ${hostState.round} 局已開始，請排牌`);
      openArrangeModal();
      startArrangeTimer();
    }

    function computeDealerIdFromSubmissions() {
      // Default: compare dealerCard as usual (ghost / selection override is handled by hostState.dealerOverride)
      const ids = roundPlayerIds();
      let bestId = null;
      for (const id of ids) {
        const sub = hostState.submissions[id];
        if (!sub || !sub.dealerCard) continue;
        if (!bestId) { bestId = id; continue; }
        const cmp = compareSelectCard(sub.dealerCard, hostState.submissions[bestId].dealerCard);
        if (cmp > 0) bestId = id;
        if (cmp === 0) {
          // deterministic tie-break
          if (String(id) > String(bestId)) bestId = id;
        }
      }
      return bestId;
    }

function revealRound() {
      if (!isHost) return;
      if (hostState.revealed) return;
      // Ensure table reveal is visible for host (avoid being hidden under status modal)
      try { $('statusModal')?.classList.add('hidden');
      } catch {}
      try { updateBodyOverflow();
      } catch {}

      const ids = roundPlayerIds();
      const missing = ids.filter(id => !hostState.submissions[id]);
      if (missing.length) {
        toast('尚有玩家未提交，無法結算');
        return;
      }
      const noDealerPick = ids.filter(id => !hostState.submissions[id]?.dealerCard);
      if (noDealerPick.length) {
        toast('有人未選莊牌，無法結算');
        return;
      }

      // Precompute eval + report validation for every player
      const evalMap = {};
      const reportMap = {};
      const foulMap = {}; // id -> {foul,msg}

      for (const id of ids) {
        const sub = hostState.submissions[id];
        const se = { head: eval2(sub.head), mid: eval3(sub.mid), tail: eval3(sub.tail) };
        evalMap[id] = se;
        const all9 = [sub.dealerCard, ...sub.head, ...sub.mid, ...sub.tail];
        const sp = validateSpecial(sub.report, all9, sub, se);
        reportMap[id] = sp;
        foulMap[id] = detectFoul(sub.head, sub.mid, sub.tail);
      }

      // 擺烏龍判定修正：若報到有效，則無視排牌大小（不計為擺烏龍）
      const wulongSet = new Set();
      for (const id of ids) {
        const sub = hostState.submissions[id];
        const reportCode = sub.report || 'none';
        const sp = reportMap[id] || {ok:true, bonus:0};
        
        // 是否為有效報到
        const isReportValid = (reportCode !== 'none' && sp.ok && sp.bonus > 0);

        // 只有在「沒有有效報到」的情況下，才檢查頭中尾大小是否烏龍
        if (!isReportValid && foulMap[id]?.foul) {
            wulongSet.add(id);
        }
        // 報到但牌型不符 -> 視為擺烏龍
        if (reportCode !== 'none' && !isReportValid) {
            wulongSet.add(id);
        }
      }

      // 決定莊家：照常用結算前指定或比選莊牌
      let dealerId = hostState.dealerOverride || computeDealerIdFromSubmissions();
      hostState.dealerOverride = null;
      if (!dealerId) {
        toast('無法決定莊家（資料不足）');
        return;
      }
      hostState.dealerId = dealerId;

      const dealerSub = hostState.submissions[dealerId];
      const dealerEval = evalMap[dealerId];
      // 閒家報到成功優先於莊家報到成功
      let hasNonDealerReportOk = false;
      for (const id of ids) {
        if (id === dealerId) continue;
        const sub = hostState.submissions[id];
        const reportCode = sub.report || 'none';
        const sp = reportMap[id] || {ok:true, bonus:0};
        if (reportCode !== 'none' && sp.ok && sp.bonus > 0) {
          hasNonDealerReportOk = true;
          break;
        }
      }

      const dealerReportCode = dealerSub?.report || 'none';
      const dealerReport = reportMap[dealerId] || {ok:false, bonus:0};
      const dealerReportOk = dealerReportCode !== 'none' && dealerReport.ok && dealerReport.bonus > 0;

      // 分支：莊家報到有效（本局不比三墩）
      // 修正：只要莊家報到有效就執行，不再檢查 wulongSet.size === 0（因有效報到者已從 wulongSet 排除）
      if (dealerReportOk) {
        const bonus = dealerReport.bonus;
        // 1) 只有莊家報到
        if (!hasNonDealerReportOk) {
          const results = {};
          for (const id of ids) {
            const sub = hostState.submissions[id];
            const se = evalMap[id];
            const isDealer = id === dealerId;
            results[id] = {
              total: isDealer ? (bonus * (ids.length - 1)) : -bonus,
              note: isDealer ? `莊家報到+${bonus}×${ids.length - 1}（本局只計報到）` : `被莊家報到-${bonus}`,
              per: {head:0, mid:0, tail:0},
              report: sub.report || 'none',
              evalNames: { head: se.head.name, mid: se.mid.name, tail: se.tail.name },
              dealerCard: sub.dealerCard,
            };
          }

          for (const id of ids) {
            hostState.cumulative[id] = Number(hostState.cumulative[id] || 0) + Number(results[id]?.total || 0);
          }

          const payload = {
            t:'reveal',
            round: hostState.round,
            dealerId,
            results,
            submissions: sanitizeSubsForBroadcast(),
            players: allPlayersForBroadcast(),
            cumulative: hostState.cumulative,
          };

          hostState.revealed = true;
          broadcast(payload);

          clientState.lastReveal = payload;
          clientState.dealerId = dealerId;
          clientState.cumulative = hostState.cumulative;
          renderGameHeader();
          renderScores(payload);
          updateMyCumulative();
          try { clientState.readyMap = readyMapForBroadcast();
          } catch {}
          try { renderTableSeats(); playRevealOnTable(payload);
          } catch {}
          $('btnOpenLastReveal').classList.remove('hidden');
          updateMidActionButton();
          try { updateMidActionButton();
          } catch {}
          glog('房主已結算本局');
          try {
            if (persistState.enabled) {
              maybeSavePersistRecordAfterRound().catch(()=>{});
            }
          } catch {}

          if (hostState.round >= hostState.settings.roundsTotal) {
            const roomRef = hostRoomId || clientState.roomId || myId;
            const overPayload = {
              t:'gameOver',
              roomId: roomRef,
              players: allPlayersForBroadcast(),
              cumulative: hostState.cumulative,
            };
            //broadcast(overPayload);
            clientState.pendingGameOver = {
              roomId: roomRef,
              players: overPayload.players,
              cumulative: overPayload.cumulative,
            };
            glog('所有局數完成（關閉本局結算後顯示總結）');
          }
          return;
        }

        // 2) 莊家報到 + 存在閒家報到：莊家報到只對「未報到」閒家生效
        const results = {};
        let dealerNet = 0;
        let affectedCount = 0;

        for (const id of ids) {
          const sub = hostState.submissions[id];
          const se = evalMap[id];
          const reportCode = sub.report || 'none';
          const sp = reportMap[id] || {ok:true, bonus:0};
          if (id === dealerId) continue;

          // 閒家報到成功：只計閒家報到（莊家扣除）
          if (reportCode !== 'none' && sp.ok && sp.bonus > 0) {
            results[id] = {
              total: sp.bonus,
              note: `報到+${sp.bonus}（本局只計報到）`,
              per: {head:0, mid:0, tail:0},
              report: reportCode,
              evalNames: { head: se.head.name, mid: se.mid.name, tail: se.tail.name },
              dealerCard: sub.dealerCard,
            };
            dealerNet -= sp.bonus;
            continue;
          }

          // 沒報到（或擺烏龍）：受莊家報到影響
          results[id] = {
            total: -bonus,
            note: `被莊家報到-${bonus}`,
            per: {head:0, mid:0, tail:0},
            report: reportCode,
            evalNames: { head: se.head.name, mid: se.mid.name, tail: se.tail.name },
            dealerCard: sub.dealerCard,
          };
          dealerNet += bonus;
          affectedCount += 1;
        }

        // dealer (net)
        const dealerSe = evalMap[dealerId];
        results[dealerId] = {
          total: dealerNet,
          note: `莊家報到+${bonus}×${affectedCount}（已扣除閒家報到；本局只計報到）`,
          per: {head:0, mid:0, tail:0},
          report: dealerReportCode,
          evalNames: { head: dealerSe.head.name, mid: dealerSe.mid.name, tail: dealerSe.tail.name },
          dealerCard: dealerSub.dealerCard,
        };
        for (const id of ids) {
          hostState.cumulative[id] = Number(hostState.cumulative[id] || 0) + Number(results[id]?.total || 0);
        }

        const payload = {
          t:'reveal',
          round: hostState.round,
          dealerId,
          results,
          submissions: sanitizeSubsForBroadcast(),
          players: allPlayersForBroadcast(),
          cumulative: hostState.cumulative,
        };
        hostState.revealed = true;
        broadcast(payload);

        clientState.lastReveal = payload;
        clientState.dealerId = dealerId;
        clientState.cumulative = hostState.cumulative;
        renderGameHeader();
        renderScores(payload);
        updateMyCumulative();
        try { clientState.readyMap = readyMapForBroadcast();
        } catch {}
        try { renderTableSeats(); playRevealOnTable(payload);
        } catch {}
        $('btnOpenLastReveal').classList.remove('hidden');
        updateMidActionButton();
        try { updateMidActionButton();
        } catch {}
        glog('房主已結算本局');
        try {
          if (persistState.enabled) {
            maybeSavePersistRecordAfterRound().catch(()=>{});
          }
        } catch {}

        if (hostState.round >= hostState.settings.roundsTotal) {
          const roomRef = hostRoomId || clientState.roomId || myId;
          const overPayload = {
            t:'gameOver',
            roomId: roomRef,
            players: allPlayersForBroadcast(),
            cumulative: hostState.cumulative,
          };
          //broadcast(overPayload);
          clientState.pendingGameOver = {
            roomId: roomRef,
            players: overPayload.players,
            cumulative: overPayload.cumulative,
          };
          glog('所有局數完成（關閉本局結算後顯示總結）');
        }
        return;
      }

      // --- 一般結算流程（含閒家擺烏龍處理） ---
      const results = {};
      let dealerNet = 0;

      for (const id of ids) {
        const sub = hostState.submissions[id];
        const se = evalMap[id];
        const reportCode = sub.report || 'none';
        const sp = reportMap[id] || {ok:true, bonus:0};
        const wulongDealer = wulongSet.has(dealerId);

        // 1) 閒家擺烏龍：只輸給莊家（但報到成功仍優先）
        if (id !== dealerId && wulongSet.has(id)) {
          // 報到成功仍優先（因為已在前面被排除出 wulongSet，理論上不會進這行，但保留邏輯以防萬一）
          if (reportCode !== 'none' && sp.ok && sp.bonus > 0) {
            const total = sp.bonus;
            results[id] = {
              total,
              note: `報到+${sp.bonus}（本局只計報到）`,
              per: {head:0, mid:0, tail:0},
              report: reportCode,
              evalNames: { head: se.head.name, mid: se.mid.name, tail: se.tail.name },
              dealerCard: sub.dealerCard,
            };
            dealerNet -= total;
            continue;
          }

          // 強制三墩全輸
          const per = {
            head: -headWinPoints(dealerEval.head),
            mid: -midWinPoints(dealerEval.mid),
            tail: -tailWinPoints(dealerEval.tail),
          };
          const total = per.head + per.mid + per.tail;

          const note = (reportCode !== 'none' && !(sp.ok && sp.bonus > 0))
            ? '報到不符→擺烏龍（本局三墩全輸）'
            : '擺烏龍（本局三墩全輸）';
          results[id] = {
            total,
            note,
            per,
            report: reportCode,
            evalNames: { head: se.head.name, mid: se.mid.name, tail: se.tail.name },
            dealerCard: sub.dealerCard,
          };
          dealerNet -= total;
          continue;
        }

        // 2) 報到有效（閒家）：不與莊對比，直接得分
        if (id !== dealerId && reportCode !== 'none' && sp.ok && sp.bonus > 0) {
          const total = sp.bonus;
          results[id] = {
            total,
            note: `報到+${sp.bonus}（本局只計報到）`,
            per: {head:0, mid:0, tail:0},
            report: reportCode,
            evalNames: { head: se.head.name, mid: se.mid.name, tail: se.tail.name },
            dealerCard: sub.dealerCard,
          };
          dealerNet -= total;
          continue;
        }

        // 3) 正常比牌（或莊家烏龍時閒家全勝）
        const per = {head:0,mid:0,tail:0};
        let total = 0;
        let noteParts = [];

        if (id !== dealerId) {
          if (wulongDealer) {
            // 莊家擺烏龍：閒家三墩一律全勝
            per.head = headWinPoints(se.head);
            per.mid  = midWinPoints(se.mid);
            per.tail = tailWinPoints(se.tail);
            total = per.head + per.mid + per.tail;
            noteParts.push('莊家失誤：三墩全勝');
          } else {
            per.head = headSectionScore(se.head, dealerEval.head);
            per.mid  = midSectionScore(se.mid, dealerEval.mid);
            per.tail = tailSectionScore(se.tail, dealerEval.tail);
            total = per.head + per.mid + per.tail;
            
            // 記錄加分細項
            if (Math.abs(per.head) !== 0 && (se.head.cat === 1 || dealerEval.head.cat === 1)) {
              if (per.head > 0 && se.head.cat === 1) noteParts.push(`頭墩對子+${headWinPoints(se.head)}`);
              if (per.head < 0 && dealerEval.head.cat === 1) noteParts.push(`頭墩對子-${headWinPoints(dealerEval.head)}`);
            }
            if (Math.abs(per.mid) !== 0 && (se.mid.cat === 5 || se.mid.cat === 4 || dealerEval.mid.cat === 5 || dealerEval.mid.cat === 4)) {
              if (per.mid > 0) {
                if (se.mid.cat === 5) noteParts.push('中墩同花順+10');
                else if (se.mid.cat === 4) noteParts.push('中墩三條+6');
              } else {
                if (dealerEval.mid.cat === 5) noteParts.push('中墩同花順-10');
                else if (dealerEval.mid.cat === 4) noteParts.push('中墩三條-6');
              }
            }
            if (Math.abs(per.tail) !== 0 && (se.tail.cat === 5 || se.tail.cat === 4 || dealerEval.tail.cat === 5 || dealerEval.tail.cat === 4)) {
              if (per.tail > 0) {
                if (se.tail.cat === 5) noteParts.push('尾墩同花順+5');
                else if (se.tail.cat === 4) noteParts.push('尾墩三條+3');
              } else {
                if (dealerEval.tail.cat === 5) noteParts.push('尾墩同花順-5');
                else if (dealerEval.tail.cat === 4) noteParts.push('尾墩三條-3');
              }
            }
          }
        }

        let note = noteParts.join('｜');
        // 報到不符但沒在前面被當烏龍處理（只有莊家可能？）
        if (reportCode !== 'none' && !(sp.ok && sp.bonus > 0)) {
          note += (note?'｜':'') + (id === dealerId ? '報到不符' : '報到不符→擺烏龍');
        }

        if (id !== dealerId) dealerNet -= total;
        results[id] = {
          total,
          note,
          per,
          report: reportCode,
          evalNames: { head: se.head.name, mid: se.mid.name, tail: se.tail.name },
          dealerCard: sub.dealerCard,
        };
      }

      // Dealer net
      if (dealerId && results[dealerId]) {
        const wulongDealer = wulongSet.has(dealerId);
        results[dealerId].total = dealerNet;
        const extra = (wulongDealer ? '擺烏龍（莊家全輸）' : '莊家淨值');
        results[dealerId].note = (results[dealerId].note ? results[dealerId].note + '｜' : '') + extra;
      }

      for (const id of ids) {
        hostState.cumulative[id] = Number(hostState.cumulative[id] || 0) + Number(results[id]?.total || 0);
      }

      const payload = {
        t:'reveal',
        round: hostState.round,
        dealerId,
        results,
        submissions: sanitizeSubsForBroadcast(),
        players: allPlayersForBroadcast(),
        cumulative: hostState.cumulative,
      };
      hostState.revealed = true;
      broadcast(payload);

      clientState.lastReveal = payload;
      clientState.dealerId = dealerId;
      clientState.cumulative = hostState.cumulative;
      renderGameHeader();
      renderScores(payload);
      updateMyCumulative();
      try { clientState.readyMap = readyMapForBroadcast();
      } catch {}
      try { renderTableSeats(); playRevealOnTable(payload);
      } catch {}

      $('btnOpenLastReveal').classList.remove('hidden');
      updateMidActionButton();
      try {
        if (persistState.enabled) {
          maybeSavePersistRecordAfterRound().catch(()=>{});
        }
      } catch {}

      if (hostState.round >= hostState.settings.roundsTotal) {
        const roomRef = hostRoomId || clientState.roomId || myId;
        const overPayload = {
          t:'gameOver',
          roomId: roomRef,
          players: allPlayersForBroadcast(),
          cumulative: hostState.cumulative,
        };
        broadcast(overPayload);
        clientState.pendingGameOver = {
          roomId: roomRef,
          players: overPayload.players,
          cumulative: overPayload.cumulative,
        };
        glog('所有局數完成（關閉本局結算後顯示總結）');
      }
    }

    function allPlayersForBroadcast() {
      const list = [{id: hostId, name: clientState.myName || '房主'}];
      for (const pid in hostState.players) list.push({id: pid, name: hostState.players[pid].name});
      return list;
    }

    function sanitizeSubsForBroadcast() {
      const out = {};
      out[hostId] = hostState.submissions[hostId] || null;
      for (const pid in hostState.players) out[pid] = hostState.submissions[pid] || null;
      return out;
    }

    // -------------------- Rendering: lobby --------------------
    function renderLobbySeats() {
      const root = $('lobbySeats');
      if (!root) return;
      root.innerHTML = '';

      const players = (() => {
        if (isHost) {
          const out = [];
          if (relaySocketOpen() && myId) out.push({id: myId, name: clientState.myName || '房主', isHost:true});
          for (const pid in hostState.players) out.push({id: pid, name: hostState.players[pid].name, isHost:false});
          return out;
        }
        const out = [];
        if (hostId) out.push({id: hostId, name: '房主', isHost:true});
        for (const pid in clientState.players) out.push({id: pid, name: clientState.players[pid].name, isHost:false});
        return out;
      })();

      const N = Math.max(0, Math.min(6, players.length));
      if (!N) return;

      // Use same circle math as game seats (but render only name)
      const rect = root.getBoundingClientRect();
      const r = (rect.width && rect.width < 420) ? 38 : 42; // percent
      const clampPct = (v) => Math.max(10, Math.min(90, v));

      for (let i=0;i<N;i++) {
        const p = players[i];
        const angle = (-90 + (360/N)*i) * (Math.PI/180);
        const x = clampPct(50 + Math.cos(angle)*r);
        const y = clampPct(50 + Math.sin(angle)*r);

        const seat = el('div', 'absolute -translate-x-1/2 -translate-y-1/2');
        seat.style.left = x + '%';
        seat.style.top = y + '%';

        const badge = el('div', 'rounded-2xl bg-black/25 border border-white/10 px-2.5 py-2 w-[104px] sm:w-[126px] overflow-hidden');

        // player icon (by name)
        const iconNode = createPlayerIconNode(p.name);
        if (iconNode) badge.appendChild(iconNode);
        
        const currentScore = clientState.cumulative[p.id] || 0;
        const scoreText = currentScore > 0 ? `+${currentScore}` : currentScore;
        const hostLabel = p.isHost ? '（房主）' : ''; 

        //const nameLine = el('div', 'text-xs font-black text-slate-50 truncate text-center', `${p.name}${hostLabel} ${scoreText}`);
        const nameLine = el('div', 'text-xs font-black text-slate-50 truncate text-center', getFormattedName(p));
        badge.appendChild(nameLine);
        
        
        badge.appendChild(el('div','text-[10px] text-emerald-100/70 mt-1 text-center', '已入座'));

        seat.appendChild(badge);
        root.appendChild(seat);
      }
    }

    function renderPlayers() {
      const list = $('playersList');
      if (list) list.innerHTML = '';
      const all = [];
      if (relaySocketOpen() && myId) {
        all.push({id: isHost ? myId : hostId || '(host)', name: isHost ? (clientState.myName+'（房主）') : '房主'});
      }

      if (!isHost) {
        for (const pid in clientState.players) all.push({id: pid, name: clientState.players[pid].name});
      } else {
        for (const pid in hostState.players) all.push({id: pid, name: hostState.players[pid].name});
      }

      $('playersCount').textContent = String(all.length);

      if (list) {
        for (const p of all) {
          const row = el('div', 'flex items-center justify-between gap-2 rounded-xl bg-black/25 border border-white/10 px-3 py-2');
          const left = el('div', 'min-w-0');
          left.appendChild(el('div', 'text-sm text-slate-50 truncate', p.name));
          left.appendChild(el('div', 'text-xs text-emerald-100/70 mono truncate', p.id));
          row.appendChild(left);
          const right = el('div', 'text-xs px-2 py-1 rounded-full bg-amber-300/10 border border-amber-200/20 text-amber-100');
          right.textContent = (p.id === hostId || (isHost && p.id === myId)) ? 'Host' : 'Player';
          row.appendChild(right);
          list.appendChild(row);
        }
      }

      setRoleBadges();
      try { renderLobbySeats(); } catch {}
      // update table seats if game page is visible
      try { renderTableSeats(); } catch {}
    }

    // -------------------- Rendering: game --------------------
    function currentPlayersListForTable() {
      // returns [{id,name,isHost}] in a stable seat order
      if (isHost) {
        const order = (Array.isArray(hostState.seatOrder) && hostState.seatOrder.length)
          ? hostState.seatOrder.slice()
          : [hostId, ...Object.keys(hostState.players || {}).sort()];

        const out = [];
        for (const id of order) {
          if (!id) continue;
          if (id === hostId) {
            out.push({id, name: clientState.myName || '房主', isHost:true});
          } else if (hostState.players?.[id]) {
            out.push({id, name: hostState.players[id].name, isHost:false});
          }
        }
        return out;
      }

      const order = (Array.isArray(clientState.seatOrder) && clientState.seatOrder.length)
        ? clientState.seatOrder.slice()
        : [hostId, ...Object.keys(clientState.players || {}).sort()];

      const out = [];
      for (const id of order) {
        if (!id) continue;
        if (id === hostId) {
          out.push({id, name: clientState.hostName || '房主', isHost:true});
        } else if (clientState.players?.[id]) {
          out.push({id, name: clientState.players[id].name, isHost:false});
        }
      }
      return out;
    }

    function renderTableSeats() {
      const root = $('tableSeats');
      if (!root) return;
      root.innerHTML = '';

      const playersAll = currentPlayersListForTable();
      const N = Math.max(1, Math.min(6, playersAll.length));
      const players = playersAll.slice(0, N);

      // [修改] 中間按鈕邏輯
      const centerBtn = document.createElement('button');
      centerBtn.type = 'button';
      centerBtn.id = 'btnOpenActionMenu';
      
      // 判斷是否處於「已結算/已比牌」狀態
      // 房主看 hostState.revealed，玩家看 clientState.lastReveal
      const isRoundOver = isHost ? hostState.revealed : !!clientState.lastReveal;
      const started = (isHost ? (hostState.round > 0) : (clientState.round > 0));

      if (isHost && isRoundOver) {
          // 情況 A: 房主 & 該局已結束 -> 顯示「下一局」
          centerBtn.className = 'absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-full px-6 py-3 chip bg-gradient-to-b from-emerald-400 to-emerald-600 text-emerald-50 text-sm font-black hover:brightness-110 active:scale-[0.99] transition shadow-[0_0_15px_rgba(16,185,129,0.5)]';
          centerBtn.textContent = '下一局';
          centerBtn.onclick = () => {
              nextRound(); // 直接呼叫房主的下一局函式
          };
      } else {
          // 情況 B: 正常狀態 (HKE九張 / 開始)
          centerBtn.className = 'absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-full px-6 py-3 chip text-amber-100 text-sm font-black hover:brightness-110 active:scale-[0.99] transition';
          centerBtn.textContent = (!started && isHost) ? '開始' : 'HKE九張';
          
          centerBtn.addEventListener('click', () => {
             // ...保留原本的點擊邏輯...
             const hasDealt = (clientState.cards9 && clientState.cards9.length);
             const started2 = (isHost ? (hostState.round > 0) : (clientState.round > 0));

             if (!started2 && !hasDealt) {
               if (isHost) startGame();
               else toast('等待房主開始遊戲');
               return;
             }
             if (!hasDealt) {
               toast('等待房主發牌');
               return;
             }
             openArrangeModal();
          });
      }

      root.appendChild(centerBtn);

      // Choose a smaller radius on narrow screens to avoid seats going out of bounds
      const rect = root.getBoundingClientRect();
      const r = (rect.width && rect.width < 420) ? 36 : 42; // percent
      const clampPct = (v) => Math.max(12, Math.min(88, v));

      // Rotate seats so "me" is always at the bottom (south) on every device
      const selfId = isHost ? hostId : myId;
      const selfIndex = selfId ? players.findIndex(p => p.id === selfId) : -1;
      const stepDeg = 360 / N;
      let startDeg = -90;
      if (selfIndex >= 0) {
        const selfDeg = startDeg + stepDeg * selfIndex;
        const delta = 90 - selfDeg;
        startDeg += delta;
      }
      const readyMap = isHost ? readyMapForBroadcast() : (clientState.readyMap || {});
      
      // positions around a circle
      for (let i=0;i<N;i++) {
        const p = players[i];
        const angle = (startDeg + stepDeg * i) * (Math.PI/180);
        const x = clampPct(50 + Math.cos(angle)*r);
        const y = clampPct(50 + Math.sin(angle)*r);

        const seat = el('div', 'absolute -translate-x-1/2 -translate-y-1/2');
        seat.style.left = x + '%';
        seat.style.top = y + '%';

        const badge = el('button', 'relative text-left rounded-2xl bg-black/25 border border-white/10 px-2.5 py-2 w-[104px] sm:w-[126px] overflow-visible hover:bg-black/30 active:scale-[0.99] transition');
        badge.type = 'button';
        badge.dataset.pid = p.id;
        badge.id = 'seatBadge_' + p.id;

        // player icon (by name) + dealer-card badge (shown only after reveal)
        const iconRow = el('div', 'flex items-center justify-center gap-1 mb-1');

        const iconNode = createPlayerIconNode(p.name);
        if (iconNode) {
          // remove center-only layout; we now place it inside a row
          try {
            iconNode.classList.remove('mx-auto');
            iconNode.classList.remove('mb-1');
          } catch {}

          // Ready tick (submitted)
          const ready = !!readyMap[p.id] || (!isHost && p.id === myId && clientState.submitted);
          if (ready) {
            // Put tick on top of the icon and avoid being clipped by overflow
            try { iconNode.style.overflow = 'visible'; } catch {}
            iconNode.classList.add('relative');

            const tick = el('div','absolute right-0 bottom-0 w-5 h-5 rounded-full bg-emerald-500/95 border border-emerald-200/50 flex items-center justify-center text-[11px] font-black text-emerald-950 pointer-events-none');
            tick.style.transform = 'translate(22%, 22%)';
            tick.style.zIndex = '6';
            tick.textContent = '✓';
            iconNode.appendChild(tick);
          }

          iconRow.appendChild(iconNode);
        }

        const dealerBadge = el('div', 'hidden text-[10px] px-1.5 py-0.5 rounded-md bg-black/35 border border-amber-200/20 text-amber-100 font-black mono');
        dealerBadge.id = 'seatDealer_' + p.id;

        // Only show dealer card after reveal (clientState.lastReveal)
        try {
          const dc = clientState.lastReveal?.submissions?.[p.id]?.dealerCard || null;
          if (dc) {
            dealerBadge.textContent = cardLabel(dc);
            dealerBadge.classList.remove('hidden');
          }
        } catch {}

        iconRow.appendChild(dealerBadge);
        badge.appendChild(iconRow);

        // Seat name line (dealer crown will be added during reveal)
        // 1. 取得該玩家目前的累計分數
        const curScore = clientState.cumulative[p.id] || 0;
        const curScoreText = curScore > 0 ? `+${curScore}` : curScore;

        // 2. 建立名稱時，直接包含分數
        const nameLine = el('div', 'text-xs font-black text-slate-50 truncate text-center', `${p.name}${p.isHost ? '（房主）' : ''} ${curScoreText}`);
        nameLine.id = 'seatName_' + p.id;
        badge.appendChild(nameLine);
        
        // 房主踢人按鈕 (顯示在頭像右上角)
        if (isHost && p.id !== hostId) {
            const btnKick = el('button', 'absolute -top-2 -right-2 w-5 h-5 rounded-full bg-rose-600 border border-white/30 text-white flex items-center justify-center text-[10px] shadow-lg z-10 hover:bg-rose-500');
            btnKick.textContent = '✕';
            btnKick.onclick = (e) => {
                e.stopPropagation(); // 防止觸發座位的點擊事件 (丟大便)
                if (confirm(`確定要踢出「${p.name}」嗎？`)) {
                    // 這裡不需要透過網路送，因為自己就是房主，直接模擬訊息處理即可
                    handleAsHost(null, {t:'kick', targetId: p.id});
                }
            };
            badge.appendChild(btnKick);
        }

        // (compat) keep node but do not render reveal cards inside the seat badge
        const revealBox = el('div', 'hidden');
        revealBox.id = 'seatReveal_' + p.id;
        badge.appendChild(revealBox);

        badge.addEventListener('click', (e) => {
          e.preventDefault();
          // clicking self seat does nothing
          const targetId = p.id;
          const selfId2 = isHost ? hostId : myId;
          if (!targetId || !selfId2 || targetId === selfId2) return;
          sendPoopTo(targetId);
        });

        seat.appendChild(badge);
        root.appendChild(seat);

        // floating reveal area (outside seat, pulled toward table center)
        // smaller factor => closer to table center
        const fx = clampPct(50 + (x - 50) * 0.55);
        const fy = clampPct(50 + (y - 50) * 0.55);
        const float = el('div', 'absolute z-[52] pointer-events-none w-[180px] sm:w-[220px]');
        float.id = 'seatFloat_' + p.id;
        float.style.left = fx + '%';
        float.style.top = fy + '%';
        float.style.transform = 'translate(-50%, -50%)';
        root.appendChild(float);
      }
    }

    function playRevealOnTable(payload) {
      // Ensure seats exist & order is stable for this reveal
      try { renderTableSeats(); } catch {}

      const subs = payload?.submissions || {};
      const results = payload?.results || {};
      const players = payload?.players || currentPlayersListForTable();
      const dealerId = payload?.dealerId;

      // Build seat UI: mini cards + right-side text (type + +/- points)
      const seatUi = {}; // id -> {wrap, headNodes, midNodes, tailNodes}

      // Crown on dealer seat name (inside seat badge)
      for (const p of (players || [])) {
        const n = document.getElementById('seatName_' + p.id);
        if (!n) continue;
        // remove any old crown
        const currentScore = clientState.cumulative[p.id] || 0;
        const scoreText = currentScore > 0 ? `+${currentScore}` : currentScore;
        let baseName = (p.name || '').replace(/^👑\s*/,'');
        // 移除舊的分數後綴以免重複 (簡單的 regex 處理)
        baseName = baseName.replace(/\s[+\-]?\d+$/, ''); 

        n.textContent = `${baseName} ${scoreText}`;
        if (p.id === dealerId) n.textContent = '👑 ' + n.textContent;
      }

      // Show dealer-card badge next to icon (after reveal)
      try {
        for (const p of (players || [])) {
          const b = document.getElementById('seatDealer_' + p.id);
          if (!b) continue;
          const dc = subs?.[p.id]?.dealerCard || null;
          if (dc) {
            b.textContent = cardLabel(dc);
            b.classList.remove('hidden');
          } else {
            b.classList.add('hidden');
          }
        }
      } catch {}

      const mkCardLine = (count) => {
        const line = el('div', 'flex gap-0 flex-nowrap');
        const nodes = [];
        for (let i=0;i<count;i++) {
          const n = renderCard(null, {variant:'mini', back:true});
          n.classList.add('reveal-fan');
          n.style.animationDelay = '0ms';
          line.appendChild(n);
          nodes.push(n);
        }
        return { line, nodes };
      };

      const fmtSigned = (v) => (v > 0 ? `+${v}` : String(v));

      for (const p of (players || [])) {
        const box = document.getElementById('seatFloat_' + p.id) || document.getElementById('seatReveal_' + p.id);
        if (!box) continue;
        box.innerHTML = '';
        const sub = subs[p.id];
        if (!sub) continue;

        const wrap = el('div', 'reveal-fan rounded-lg bg-black/25 border border-white/10 p-[3px] w-full');
        wrap.style.animationDelay = (Math.random()*80) + 'ms';

        const r = results[p.id] || { per:{head:0,mid:0,tail:0}, total:0, evalNames:{head:'',mid:'',tail:''}, note:'', report:'none' };
        const e = r.evalNames || {};
        const per = r.per || {head:0,mid:0,tail:0};

        const noteStr = String(r.note || '');
        // Only treat as wulong for display if this player itself is wulong.
        // (Dealer wulong should not make other players look like wulong)
        const isWulong = (noteStr.includes('擺烏龍')) && !noteStr.includes('莊家失誤');
        const isReportOnly = (!isWulong) && (r.report && r.report !== 'none') && noteStr.includes('只計報到');
        const reportBonus = isReportOnly ? Number(r.total || 0) : 0;

        const shortReportName = (code) => {
          const full = String(specialLabel(code) || '').trim();
          const idx = full.indexOf(' +');
          return idx > 0 ? full.slice(0, idx) : full;
        };

        const mkLine = (label, evalName, v, mode='normal') => {
          // Use a fixed "cards column" width so head text aligns with mid/tail text.
          // 3 mini-cards width ~= 96px (incl. overlap); keep a little gutter.
          const row = el('div','flex items-center gap-2');
          const leftCol = el('div','shrink-0 flex items-center');
          leftCol.style.width = '106px';
          row.appendChild(leftCol);

          const cardsWrap = el('div','flex gap-0 flex-nowrap');
          leftCol.appendChild(cardsWrap);

          // 報到模式：不顯示三墩牌型/分數文字，只顯示卡片
          if (mode === 'report') return {row, left: cardsWrap};

          const right = el('div','min-w-0 flex-1 text-[10px] leading-tight text-emerald-50/90 flex items-center justify-between gap-2');

          const txt = el('div','truncate');
          if (mode === 'wulong') {
            txt.innerHTML = `<span class="text-rose-200 font-black">擺烏龍</span>`;
          } else {
            txt.innerHTML = `<span class="text-emerald-100/70">${label}</span> ${evalName||''}`;
          }

          const scoreText = fmtSigned(v||0);
          const scoreCls = (v>0?'text-emerald-200':(v<0?'text-rose-200':'text-emerald-50/60'));
          const score = el('div', `shrink-0 mono font-black ${scoreCls}`, scoreText);

          right.appendChild(txt);
          right.appendChild(score);
          row.appendChild(right);
          return {row, left: cardsWrap};
        };

        const head = mkCardLine(2);
        const mid  = mkCardLine(3);
        const tail = mkCardLine(3);

        const mode = isWulong ? 'wulong' : (isReportOnly ? 'report' : 'normal');
        const l1 = mkLine('頭', e.head, per.head||0, mode);
        const l2 = mkLine('中', e.mid, per.mid||0, mode);
        const l3 = mkLine('尾', e.tail, per.tail||0, mode);

        l1.left.appendChild(head.line);
        l2.left.appendChild(mid.line);
        l3.left.appendChild(tail.line);

        // Vertical ~50% overlap between sections
        l2.row.classList.add('-mt-[18px]');
        l3.row.classList.add('-mt-[18px]');

        wrap.appendChild(l1.row);
        wrap.appendChild(l2.row);
        wrap.appendChild(l3.row);

        if (mode === 'report') {
          const repLine = el('div', 'mt-[2px] text-[10px] font-black text-amber-100', `報到：${shortReportName(r.report)} +${reportBonus}`);
          wrap.appendChild(repLine);
        } else {
          // total line
          const totalLine = el('div','mt-[2px] text-[10px] font-black mono text-right');
          totalLine.className = 'mt-[2px] text-[10px] font-black mono text-right ' + (Number(r.total||0)>0?'text-emerald-200':(Number(r.total||0)<0?'text-rose-200':'text-emerald-50/70'));
          totalLine.textContent = `本局 ${fmtSigned(Number(r.total||0))}`;
          wrap.appendChild(totalLine);
        }

        box.appendChild(wrap);
        seatUi[p.id] = {wrap, head: head.nodes, mid: mid.nodes, tail: tail.nodes};
      }

      // ---------- sequential reveal order ----------
      const evalFor = (pid, section) => {
        const sub = subs[pid];
        if (!sub) return null;
        if (section === 'head') return eval2(sub.head);
        if (section === 'mid') return eval3(sub.mid);
        if (section === 'tail') return eval3(sub.tail);
        return null;
      };

      const sortPlayersBySection = (section) => {
        const list = (players || []).filter(p => p.id !== dealerId && subs[p.id]);
        // small -> big
        list.sort((a,b) => {
          const ea = evalFor(a.id, section);
          const eb = evalFor(b.id, section);
          const cmp = compareEval(ea, eb);
          if (cmp !== 0) return cmp;
          return String(a.id) < String(b.id) ? -1 : 1;
        });
        return list;
      };

      const steps = [];
      const pushReveal = (pid, section, cards) => {
        steps.push({pid, section, cards});
      };

      // Dealer first each section, then others by small->big
      const dealerSub = subs[dealerId];
      if (dealerSub) pushReveal(dealerId, 'head', dealerSub.head);
      for (const p of sortPlayersBySection('head')) pushReveal(p.id, 'head', subs[p.id].head);

      if (dealerSub) pushReveal(dealerId, 'mid', dealerSub.mid);
      for (const p of sortPlayersBySection('mid')) pushReveal(p.id, 'mid', subs[p.id].mid);

      if (dealerSub) pushReveal(dealerId, 'tail', dealerSub.tail);
      for (const p of sortPlayersBySection('tail')) pushReveal(p.id, 'tail', subs[p.id].tail);

      const flipOne = (placeholderNode, card) => {
        const parent = placeholderNode.parentElement;
        const newNode = renderCard(card, {variant:'mini'});
        newNode.classList.add('reveal-fan');
        newNode.style.animationDelay = '0ms';
        parent.replaceChild(newNode, placeholderNode);
        return newNode;
      };

      const sleep = (ms) => new Promise(r => setTimeout(r, ms));

      (async () => {
        let delay = 240; // slow down ~2x
        for (const step of steps) {
          const ui = seatUi[step.pid];
          if (!ui) continue;
          const nodes = ui[step.section];
          if (!nodes) continue;
          for (let i=0;i<Math.min(nodes.length, step.cards.length);i++) {
            const old = nodes[i];
            const newNode = flipOne(old, step.cards[i]);
            nodes[i] = newNode;
            await sleep(delay);
            delay = Math.max(140, delay - 8);
          }
          await sleep(240);
        }
      })();
    }

    // -------------------- Rendering: game --------------------
    function getNameById(id) {
      if (!id) return '—';
      if (id === hostId && isHost) return clientState.myName + '（房主）';
      if (isHost) {
        if (id === hostId) return clientState.myName + '（房主）';
        return hostState.players[id]?.name || id;
      }
      if (id === hostId) return '房主';
      return clientState.players[id]?.name || id;
    }

    function updateMyCumulative() {
      const id = isHost ? hostId : myId;
      const v = Number((isHost ? hostState.cumulative : clientState.cumulative)?.[id] || 0);
      $('myCumulative').textContent = String(v);
    }

    function renderGameHeader() {
      const room = isHost ? (myId || '—') : (clientState.roomId || '—');
      $('gameRoomId').textContent = room;
      const roundsTotal = isHost ? hostState.settings.roundsTotal : clientState.settings.roundsTotal;
      const round = isHost ? hostState.round : clientState.round;
      $('gameRoundInfo').textContent = round ? `${round} / ${roundsTotal}` : `— / ${roundsTotal}`;
      const dealerId = isHost ? hostState.dealerId : clientState.dealerId;
      $('dealerName').textContent = dealerId ? getNameById(dealerId) : '待定';

      updateMyCumulative();
      renderDealerCardSlot();
    }

    function renderCard(c, opts={}) {
      // opts:
      // - variant: 'hand' | 'slot' | 'mini'
      // - back: boolean (render card back)
      const key = c ? cardKey(c) : '';
      const isJ = c?.s === 'J';

      const variant = opts.variant || (opts.small ? 'slot' : 'hand');
      const sizeCls = variant === 'slot'
        ? 'pc-slot w-full h-full'
        : (variant === 'mini'
          ? 'pc-mini w-[25px] h-[35px] sm:w-[30px] sm:h-[42px]'
          : (variant === 'hand'
            ? 'pc-hand w-[66px] h-[92px] sm:w-[72px] sm:h-[100px]'
            : 'pc-hand w-[92px] h-[128px]'));

      const suitClass = !c ? '' : (isJ ? 'text-violet-700' : SUIT_COLOR[c.s]);

      const btn = el('button', `card poker-card ${sizeCls} ${isJ ? 'pc-joker' : ''} ${variant==='mini' ? 'pc-mini' : ''} ${suitClass} transition`);
      if (opts.back) btn.classList.add('card-back');
      if (key) btn.dataset.key = key;
      btn.style.borderColor = opts.selected ? 'rgba(99,102,241,.9)' : 'rgba(15,23,42,.22)';

      // If back, do not render faces
      if (opts.back) return btn;
      if (!c) return btn;

      // content
      const tl = el('div', 'pcorner tl');
      const br = el('div', 'pcorner br');

      if (isJ) {
        tl.appendChild(el('div','prank', 'J'));
        tl.appendChild(el('div','psuit', '☆'));
        br.appendChild(el('div','prank', 'J'));
        br.appendChild(el('div','psuit', '☆'));

        const center = el('div','pcenter');
        center.textContent = (c.j === 'BJ') ? '大鬼' : '細鬼';
        btn.appendChild(center);
      } else {
        const rank = c.r;
        const rtxt = rank<=10 ? String(rank) : (rank===11?'J':rank===12?'Q':rank===13?'K':'A');
        const suit = SUIT_ICON[c.s];

        tl.appendChild(el('div','prank', rtxt));
        tl.appendChild(el('div','psuit', suit));
        br.appendChild(el('div','prank', rtxt));
        br.appendChild(el('div','psuit', suit));

        const center = el('div','pcenter', suit);
        btn.appendChild(center);
      }

      btn.appendChild(tl);
      btn.appendChild(br);

      if (opts.selected) {
        btn.classList.add('ring-2', 'ring-indigo-500/30');
      }
      if (opts.locked) {
        btn.classList.add('opacity-95');
        btn.disabled = true;
      }
      // --- 新增開始 ---
      // 只有在手牌(hand)、卡槽(slot)或選莊(dealer)內的牌才需要拖曳
      // 排除 mini (結算畫面)
      if (opts.variant !== 'mini' && !opts.locked && !opts.back) {
        // 為了讓 elementFromPoint 能抓到，加入 drop-zone 標記
        // (這樣如果拖牌去撞另一張牌，也能識別為目標)
        if (opts.variant === 'hand') {
             btn.dataset.dropZone = 'true';
             btn.dataset.zone = 'hand';
        }
        
        // 準備來源資料 ref
        let srcRef = null;
        if (opts.variant === 'hand') srcRef = { zone: 'hand', key: key };
        // 注意：卡槽內的牌是在 renderSlotCell 時處理，但卡牌本身也需要能被抓起來
        // 這裡我們先設定通用事件，具體 ref 由外部或 dataset 決定
        // 簡單起見，我們讓 renderHand 和 renderSlotCell 呼叫 renderCard 後再綁定具體 ref，
        // 或者在這裡判斷。
        
        // 綁定事件
        const startDrag = (e) => {
            // 如果是在 Slot 裡的牌，我們需要知道是哪個 Slot
            // 透過 DOM 往上找
            let ref = srcRef; 
            if (!ref) {
                const parentSlot = btn.closest('[data-zone="slot"]');
                if (parentSlot) {
                    ref = { 
                        zone: 'slot', 
                        slot: parentSlot.dataset.slot, 
                        idx: parseInt(parentSlot.dataset.idx) 
                    };
                }
                const parentDealer = btn.closest('[data-zone="dealer"]');
                if (parentDealer) {
                    ref = { zone: 'dealer' };
                }
            }
            if (ref) handleDragStart(e, ref);
        };

        btn.addEventListener('touchstart', startDrag, {passive: false});
        btn.addEventListener('mousedown', startDrag);
        
        // 重要：CSS 確保手指不會觸發瀏覽器縮放
        btn.style.touchAction = 'none'; 
      }
      // --- 新增結束 ---

      return btn;
    }

    function currentHandCards() {
      const dealerKey = clientState.dealerCard ? cardKey(clientState.dealerCard) : null;
      const suitOrder = {C:1, D:2, H:3, S:4, J:5};
      return (clientState.cards9 || [])
        .filter(c => cardKey(c) !== dealerKey)
        .filter(c => !clientState.usedFromHand.has(cardKey(c)))
        .slice()
        .sort((a,b) => {
          // rank asc, then suit asc (C<D<H<S), jokers last by r (15/16) and suitOrder
          const ra = (a.s === 'J') ? a.r : a.r;
          const rb = (b.s === 'J') ? b.r : b.r;
          if (ra !== rb) return ra - rb;
          return (suitOrder[a.s]||0) - (suitOrder[b.s]||0);
        });
    }

    function renderDealerCardSlot() {
      const slot = $('dealerCardSlot');
      slot.innerHTML = '';
      
      // --- 新增 ---
      slot.dataset.dropZone = 'true';
      slot.dataset.zone = 'dealer';
      // -----------

      if (!clientState.dealerCard) {
        const box = el('div', 'h-[70px] w-[50px] sm:h-[80px] sm:w-[58px] rounded-lg border-2 border-dashed border-amber-200/30 bg-amber-400/5 flex items-center justify-center text-xs font-bold text-amber-100/50', '莊');
        box.addEventListener('click', (e) => {
          if (e.target.closest('button')) return;
          if (clientState.submitted) return;
          if (!clientState.pick) return;
          // move selected card into dealer slot
          onPick({zone:'dealer'});
        });
        slot.appendChild(box);
        return;
      }

      const selected = clientState.pick?.zone === 'dealer';
      const btn = renderCard(clientState.dealerCard, {variant:'slot', selected});
      btn.addEventListener('click', () => onPick({zone:'dealer'}));
      slot.appendChild(btn);
    }

    function renderHand() {
      const handEl = $('hand');
      
      // 1. 強制重置樣式，確保手牌區可見 (修復拖曳後消失的問題)
      handEl.classList.remove('translate-y-[150%]', 'opacity-0');
      
      // 2. 清空內容
      handEl.innerHTML = '';
      
      // 3. 確保手牌區有過渡動畫效果
      handEl.classList.add('transition-all', 'duration-300', 'ease-out');

      // 4. 準備手牌資料 (過濾掉已排到桌上的牌)
      // 注意：clientState.cards9 是物件陣列，不是字串
      const dealerKey = clientState.dealerCard ? cardKey(clientState.dealerCard) : null;
      
      const remaining = (clientState.cards9 || []).filter(c => {
        const key = cardKey(c);
        // 過濾掉：已放入排牌區的牌 或 已選為莊家的牌
        return !clientState.usedFromHand.has(key) && key !== dealerKey;
      });

      // 5. 排序邏輯 (依點數大小)
      const suitOrder = {S:4, H:3, D:2, C:1, J:5}; // 花色權重
      remaining.sort((a,b) => {
        // 大鬼(16) > 細鬼(15) > A(14) > K(13)...
        // 如果是鬼牌，rank 分別是 16, 15，數字牌則依 r
        const ra = a.r; 
        const rb = b.r;
        if (ra !== rb) return ra - rb; // 點數小的在左，大的在右 (或反過來 rb - ra)
        return (suitOrder[a.s]||0) - (suitOrder[b.s]||0);
      });

      // 6. 產生卡片 DOM
      remaining.forEach(c => {
        // 判斷是否被選取 (Pick)
        const key = cardKey(c);
        const isSelected = (clientState.pick && clientState.pick.zone === 'hand' && clientState.pick.key === key);

        // 使用專用的 renderCard 函式來產生卡片 (它包含了正確的樣式與拖曳事件)
        const btn = renderCard(c, { variant: 'hand', selected: isSelected });

        // 綁定點擊事件 (處理選取/互換)
        btn.onclick = (e) => {
          // 阻止事件冒泡，避免觸發其他層的點擊
          e.stopPropagation();
          onPick({zone: 'hand', key: key});
        };

        // 將卡片加入手牌區
        handEl.appendChild(btn);
      });
    }

    function labelForKey(key) {
      const c = clientState.cards9.find(x => cardKey(x)===key) || (clientState.dealerCard && cardKey(clientState.dealerCard)===key ? clientState.dealerCard : null);
      return c ? cardLabel(c) : key;
    }

    function rebuildUsedFromHand() {
      const s = new Set();
      for (const slotName of ['head','mid','tail']) {
        for (const c of (clientState.arranged[slotName] || [])) {
          if (c) s.add(cardKey(c));
        }
      }
      clientState.usedFromHand = s;
    }

    function refCard(ref) {
      if (!ref) return null;
      if (ref.zone === 'hand') return clientState.cards9.find(x => cardKey(x) === ref.key) || null;
      if (ref.zone === 'dealer') return clientState.dealerCard || null;
      if (ref.zone === 'slot') return clientState.arranged?.[ref.slot]?.[ref.idx] || null;
      return null;
    }

    function sameRef(a,b) {
      if (!a || !b) return false;
      if (a.zone !== b.zone) return false;
      if (a.zone === 'hand') return a.key === b.key;
      if (a.zone === 'dealer') return true;
      if (a.zone === 'slot') return a.slot === b.slot && a.idx === b.idx;
      return false;
    }

    function updateSelectedHint() {
      const p = clientState.pick;
      if (!p) {
        //$('selectedHint').textContent = '未選取牌';
        return;
      }
      let label = '';
      //if (p.zone === 'hand') label = `手牌：${labelForKey(p.key)}`;
      if (p.zone === 'dealer') label = `選莊牌：${cardLabel(clientState.dealerCard)}`;
      if (p.zone === 'slot') {
        const cname = p.slot==='head' ? '頭墩' : (p.slot==='mid' ? '中墩' : '尾墩');
        const c = clientState.arranged[p.slot][p.idx];
        label = `${cname}#${p.idx+1}：${c ? cardLabel(c) : '—'}`;
      }
     // $('selectedHint').textContent = `已選取（可再點另一張牌互換；點空格可移動）：${label}`;
    }

    function clearPick() {
      clientState.pick = null;
      updateSelectedHint();
    }

    function applySwapOrMove(aRef, bRef) {
      if (!aRef || !bRef) return;
      const a = refCard(aRef);
      const b = refCard(bRef);

      // hand <-> hand: swap order only
      if (aRef.zone === 'hand' && bRef.zone === 'hand') {
        const i = clientState.cards9.findIndex(c => cardKey(c) === aRef.key);
        const j = clientState.cards9.findIndex(c => cardKey(c) === bRef.key);
        if (i >= 0 && j >= 0) [clientState.cards9[i], clientState.cards9[j]] = [clientState.cards9[j], clientState.cards9[i]];
        return;
      }

      // If destination has no card: treat as move
      if (a && !b) {
        if (bRef.zone === 'dealer') {
          // move to dealer slot
          clientState.dealerCard = a;
          if (aRef.zone === 'slot') clientState.arranged[aRef.slot][aRef.idx] = null;
          if (aRef.zone === 'dealer') clientState.dealerCard = null;
        }
        if (bRef.zone === 'slot') {
          clientState.arranged[bRef.slot][bRef.idx] = a;
          if (aRef.zone === 'slot') clientState.arranged[aRef.slot][aRef.idx] = null;
          if (aRef.zone === 'dealer') clientState.dealerCard = null;
        }
        rebuildUsedFromHand();
        return;
      }
      if (!a && b) {
        // swapOrMove(b,a)
        applySwapOrMove(bRef, aRef);
        return;
      }
      if (!a && !b) return;

      // swap non-hand refs
      if (aRef.zone === 'dealer' && bRef.zone === 'slot') {
        clientState.dealerCard = b;
        clientState.arranged[bRef.slot][bRef.idx] = a;
        rebuildUsedFromHand();
        return;
      }
      if (aRef.zone === 'slot' && bRef.zone === 'dealer') {
        clientState.arranged[aRef.slot][aRef.idx] = b;
        clientState.dealerCard = a;
        rebuildUsedFromHand();
        return;
      }

      if (aRef.zone === 'slot' && bRef.zone === 'slot') {
        clientState.arranged[aRef.slot][aRef.idx] = b;
        clientState.arranged[bRef.slot][bRef.idx] = a;
        rebuildUsedFromHand();
        return;
      }

      // hand <-> dealer
      if (aRef.zone === 'hand' && bRef.zone === 'dealer') {
        clientState.dealerCard = a;
        return;
      }
      if (aRef.zone === 'dealer' && bRef.zone === 'hand') {
        clientState.dealerCard = b;
        return;
      }

      // hand <-> slot
      if (aRef.zone === 'hand' && bRef.zone === 'slot') {
        clientState.arranged[bRef.slot][bRef.idx] = a;
        rebuildUsedFromHand();
        return;
      }
      if (aRef.zone === 'slot' && bRef.zone === 'hand') {
        clientState.arranged[aRef.slot][aRef.idx] = b;
        rebuildUsedFromHand();
        return;
      }
    }

    function onPick(ref) {
      if (clientState.submitted) {
        toast('已提交，無法更動');
        return;
      }

      if (!clientState.pick) {
        clientState.pick = ref;
        updateSelectedHint();
        renderGameHeader();
        renderHand();
        renderSlots();
        return;
      }

      if (sameRef(clientState.pick, ref)) {
        clearPick();
        renderGameHeader();
        renderHand();
        renderSlots();
        return;
      }

      applySwapOrMove(clientState.pick, ref);
      clearPick();

      // Dealer card might be Joker; dealer will be decided in pre-reveal dealer-pick phase.
      // Clear any previous per-submit dealer target (feature removed).
      if (!(clientState.dealerCard && clientState.dealerCard.s === 'J')) {
        clientState.dealerTargetId = null;
      }

      renderGameHeader();
      renderHand();
      renderSlots();
    }

    function renderSlotCell(slotName, idx) {
      // Poker-card slot (match card aspect ratio) - ultra compact
      const cell = el('div', 'h-[70px] w-[50px] sm:h-[80px] sm:w-[58px] rounded-lg border-2 border-white/10 bg-white/5 flex items-center justify-center transition-colors');
      
      // --- 新增開始 ---
      // 標記這是一個可放置的區域
      cell.dataset.dropZone = 'true';
      cell.dataset.zone = 'slot';
      cell.dataset.slot = slotName;
      cell.dataset.idx = idx;
      // --- 新增結束 ---
      const arr = clientState.arranged[slotName];
      const c = arr[idx];

      if (!c) {
        cell.appendChild(el('div', 'text-[10px] text-emerald-100/55 text-center leading-snug', '放牌'));
        cell.appendChild(el('div', 'text-xs sm:text-sm text-emerald-100/30 font-bold pointer-events-none', '＋'));
      } else {
        const selected = clientState.pick?.zone==='slot' && clientState.pick.slot===slotName && clientState.pick.idx===idx;
        const btn = renderCard(c, {variant:'slot', selected});
        btn.addEventListener('click', () => onPick({zone:'slot', slot: slotName, idx}));
        cell.appendChild(btn);
      }

      cell.addEventListener('click', (e) => {
        if (e.target.closest('button')) return;
        if (clientState.submitted) return;
        if (!clientState.pick) return;
        // move selected into this empty slot
        onPick({zone:'slot', slot: slotName, idx});
      });

      return cell;
    }

    function renderSlots() {
      const sizes = { head: 2, mid: 3, tail: 3 };
      const makeSlot = (id, slotName) => {
        const root = $(id);
        root.innerHTML = '';
        for (let i=0;i<sizes[slotName];i++) root.appendChild(renderSlotCell(slotName, i));
      };

      makeSlot('slotHead', 'head');
      makeSlot('slotMid', 'mid');
      makeSlot('slotTail', 'tail');

      const h = clientState.arranged.head;
      const m = clientState.arranged.mid;
      const t = clientState.arranged.tail;
      $('headEval').textContent = isAllFilled(h) ? eval2(h).name : '—';
      $('midEval').textContent = isAllFilled(m) ? eval3(m).name : '—';
      $('tailEval').textContent = isAllFilled(t) ? eval3(t).name : '—';

      // 不再即時提示擺烏龍（允許提交；結算時才處理）
      $('foulHint').textContent = '擺烏龍：頭 > 中 或 中 > 尾（允許提交；閒家擺烏龍則本局只輸給莊家；莊家擺烏龍本局三墩全輸；報到不符亦作擺烏龍）';
      $('foulHint').className = 'text-xs text-emerald-100/70';
    }

    function updateMidActionButton() {
      const btn = $('btnMidAction');
      if (!btn) return;

      // Host: show "下一局" as long as a round has been revealed (some flows may set lastReveal but not repaint revealed flag in time)
      const hostCanNext = isHost && (!!hostState.revealed || !!clientState.lastReveal);
      btn.textContent = hostCanNext ? '下一局' : '牌組';

      // Reset class to baseline then add active style
      btn.className = 'flex-1 text-xs px-3 py-2 rounded-xl border ' + (hostCanNext
        ? 'bg-gradient-to-b from-emerald-400 to-emerald-500 text-emerald-950 font-semibold border-emerald-200/20'
        : 'bg-white/10 hover:bg-white/15 text-slate-50 border-white/10');
    }

    function renderReadyList(readyMap=null) {
      const root = $('readyList');
      if (!root) return;
      root.innerHTML = '';

      let players = [];
      if (isHost) {
        players = [{id: hostId, name: clientState.myName + '（房主）'}];
        for (const pid in hostState.players) players.push({id: pid, name: hostState.players[pid].name});
      } else {
        players = [{id: hostId, name: '房主'}];
        for (const pid in clientState.players) players.push({id: pid, name: clientState.players[pid].name});
      }

      const rmap = readyMap || null;

      for (const p of players) {
        const row = el('div', 'flex items-center justify-between gap-2 rounded-xl bg-black/25 border border-white/10 px-3 py-2');
        row.appendChild(el('div', 'text-sm text-slate-50 truncate', p.name));
        const ready = rmap ? !!rmap[p.id] : false;
        const badge = el('div', `text-xs px-2 py-1 rounded-full ${ready ? 'bg-emerald-500/15 border border-emerald-300/25 text-emerald-100' : 'bg-white/10 border border-white/10 text-emerald-50/80'}`, ready ? '已提交' : '未提交');
        row.appendChild(badge);
        root.appendChild(row);
      }

      if (isHost) {
        $('btnNextRound').classList.toggle('hidden', !hostState.revealed);
      }
    }

    function renderScores(revealPayload) {
      const body = $('scoreBody');
      if (!body) return;
      body.innerHTML = '';
      if (!revealPayload) return;

      const players = revealPayload.players || [];
      const dealerId = revealPayload.dealerId;
      const results = revealPayload.results || {};
      const subs = revealPayload.submissions || {};
      const cumulative = revealPayload.cumulative || {};

      const sorted = [...players].sort((a,b) => {
        if (a.id===dealerId) return -1;
        if (b.id===dealerId) return 1;
        return (results[b.id]?.total||0) - (results[a.id]?.total||0);
      });

      for (const p of sorted) {
        const r = results[p.id] || {per:{head:0,mid:0,tail:0}, total:0, note:'', report:'none'};
        const sub = subs[p.id];
        const dc = sub?.dealerCard;

        const tr = document.createElement('tr');
        tr.className = 'border-b border-white/5 align-top';

        const tdName = el('td','py-2 pr-2');
        tdName.appendChild(el('div','text-sm text-slate-50', p.name + (p.id===dealerId?'（莊）':'')));
        tdName.appendChild(el('div','text-[10px] text-emerald-100/70 mono', p.id));

        const tdDealer = el('td','py-2 pr-2 text-slate-50 text-xs');
        tdDealer.textContent = dc ? cardLabel(dc) : '—';

        const mk = (v) => {
          const s = v>0?`+${v}`:String(v);
          const cls = v>0?'text-emerald-200':(v<0?'text-rose-200':'text-emerald-50/80');
          return el('td',`py-2 pr-2 ${cls} mono`, s);
        };

        const tdRep = el('td','py-2 pr-2 text-emerald-50/80 text-xs');
        tdRep.textContent = r.report==='none' ? '—' : specialLabel(r.report);

        const tdTotal = el('td','py-2 pr-2 font-black mono', String(r.total));
        tdTotal.classList.add(r.total>0?'text-emerald-200':(r.total<0?'text-rose-200':'text-emerald-50/80'));

        const cumVal = Number(cumulative[p.id] || 0);
        const tdCum = el('td','py-2 pr-2 font-black mono', String(cumVal));
        tdCum.classList.add(cumVal>0?'text-emerald-200':(cumVal<0?'text-rose-200':'text-emerald-50/80'));

        const tdNote = el('td','py-2 pr-2 text-xs text-emerald-50/70', r.note || '');

        tr.appendChild(tdName);
        tr.appendChild(tdDealer);
        tr.appendChild(mk(r.per.head||0));
        tr.appendChild(mk(r.per.mid||0));
        tr.appendChild(mk(r.per.tail||0));
        tr.appendChild(tdRep);
        tr.appendChild(tdTotal);
        tr.appendChild(tdCum);
        tr.appendChild(tdNote);

        body.appendChild(tr);
      }

      renderReadyList(readyMapForReveal(revealPayload));

      function readyMapForReveal(payload) {
        const rm = {};
        for (const p of (payload.players||[])) rm[p.id] = !!payload.submissions?.[p.id];
        return rm;
      }
    }

    // -------------------- Submit / Arrange --------------------
    const ARRANGE_LIMIT_MS = 60000;
    let arrangeTimer = null;
    let arrangeCountdownTimer = null;
    let arrangeDeadline = 0;

    function setArrangeTimerText() {
      const eln = $('arrangeTimerText');
      const eln2 = $('arrangeTimerText2');
      const bb = !!(isHost ? hostState.settings.bbMode : clientState.settings.bbMode);

      const setBoth = (txt, cls=null) => {
        try {
          if (eln) {
            eln.textContent = txt;
            if (cls) eln.className = cls;
          }
        } catch {}
        try {
          if (eln2) eln2.textContent = txt.replace(/^限時\s*/,'').replace(/s$/,'');
        } catch {}
      };

      if (bb) {
        if (eln) {
          eln.textContent = 'BB';
          eln.className = 'mr-auto text-[10px] text-emerald-100/70 mono';
        }
        if (eln2) eln2.textContent = 'BB';
        return;
      }

      if (!arrangeDeadline || clientState.submitted || !(clientState.cards9 && clientState.cards9.length)) {
        if (eln) {
          eln.textContent = '—';
          eln.className = 'mr-auto text-[10px] text-emerald-100/70 mono';
        }
        if (eln2) eln2.textContent = '—';
        return;
      }

      const leftMs = Math.max(0, arrangeDeadline - Date.now());
      const sec = Math.ceil(leftMs / 1000);
      const cls = 'mr-auto text-[10px] mono ' + (sec <= 10 ? 'text-rose-200' : 'text-emerald-100/70');
      if (eln) {
        eln.textContent = `限時 ${sec}s`;
        eln.className = cls;
      }
      if (eln2) {
        eln2.textContent = `${sec}s`;
        eln2.className = 'mono ' + (sec <= 10 ? 'text-rose-200' : 'text-emerald-50/80');
      }
    }

    function stopArrangeTimer() {
      if (arrangeTimer) {
        clearTimeout(arrangeTimer);
        arrangeTimer = null;
      }
      if (arrangeCountdownTimer) {
        clearInterval(arrangeCountdownTimer);
        arrangeCountdownTimer = null;
      }
      arrangeDeadline = 0;
      setArrangeTimerText();
    }

    function autoFillRandomAllowFoul() {
      // always produce a layout (may be wulong)
      resetArrange();
      const pool = [...(clientState.cards9 || [])];
      shuffle(pool);
      const dealer = clientState.dealerCard || pool.shift();
      clientState.dealerCard = dealer;
      // remove dealer from pool
      const dk = cardKey(dealer);
      const di = pool.findIndex(c => cardKey(c)===dk);
      if (di >= 0) pool.splice(di,1);
      if (pool.length < 8) return false;
      const head = pool.slice(0,2);
      const mid = pool.slice(2,5);
      const tail = pool.slice(5,8);
      clientState.arranged.head = head;
      clientState.arranged.mid = mid;
      clientState.arranged.tail = tail;
      clientState.usedFromHand = new Set(pool.slice(0,8).map(cardKey));
      renderGameHeader();
      renderHand();
      renderSlots();
      return true;
    }

    function startArrangeTimer() {
      stopArrangeTimer();
      // BB mode disables timer
      const bb = !!(isHost ? hostState.settings.bbMode : clientState.settings.bbMode);
      if (bb) { setArrangeTimerText(); return; }
      if (!clientState.cards9 || clientState.cards9.length === 0) { setArrangeTimerText(); return; }
      if (clientState.submitted) { setArrangeTimerText(); return; }

      arrangeDeadline = Date.now() + ARRANGE_LIMIT_MS;
      setArrangeTimerText();
      arrangeCountdownTimer = setInterval(setArrangeTimerText, 250);

      arrangeTimer = setTimeout(() => {
        if (clientState.submitted) return;
        const bb2 = !!(isHost ? hostState.settings.bbMode : clientState.settings.bbMode);
        if (bb2) return;

        toast('排牌逾時，自動排牌提交');

        // try no-foul first; fallback allow foul
        try {
          autoFillRandomNoFoul();
        } catch {}

        // if still not filled, force random
        const ok = (() => {
          try {
            const {head,mid,tail} = clientState.arranged;
            return clientState.dealerCard && isAllFilled(head) && isAllFilled(mid) && isAllFilled(tail);
          } catch { return false; }
        })();

        if (!ok) {
          autoFillRandomAllowFoul();
        }

        // reset report to none to avoid accidental report
        try { $('selReport').value = 'none'; } catch {}

        // submit
        try { submitArrangement(); } catch {}
      }, ARRANGE_LIMIT_MS);
    }

    function resetArrange() {
      clientState.arranged = { head:[null,null], mid:[null,null,null], tail:[null,null,null] };
      clientState.usedFromHand = new Set();
      clientState.selectedCardKey = null;
      //$('selectedHint').textContent = '未選取牌';
      renderHand();
      renderSlots();
    }

    function autoFillRandomNoFoul() {
      if (clientState.submitted) return;
      resetArrange();

      // pick dealer card if not chosen
      let dealer = clientState.dealerCard;
      for (let tries=0; tries<80; tries++) {
        const pool = [...(clientState.cards9 || [])];
        shuffle(pool);
        if (!dealer) dealer = pool.shift();
        const dk = cardKey(dealer);
        const di = pool.findIndex(c => cardKey(c)===dk);
        if (di >= 0) pool.splice(di,1);

        if (pool.length !== 8) {
          dealer = null;
          continue;
        }

        const head = pool.slice(0,2);
        const mid = pool.slice(2,5);
        const tail = pool.slice(5,8);

        const foul = detectFoul(head, mid, tail);
        if (!foul.foul) {
          clientState.dealerCard = dealer;
          clientState.arranged.head = head;
          clientState.arranged.mid = mid;
          clientState.arranged.tail = tail;
          clientState.usedFromHand = new Set(pool.map(cardKey));
          renderGameHeader();
          renderHand();
          renderSlots();
          return;
        }

        dealer = null;
      }

      toast('快速排失敗（找不到不擺烏龍組合），請手動排');
    }

    function validateArrangement() {
      const {head,mid,tail} = clientState.arranged;
      if (!clientState.dealerCard) return {ok:false, msg:'請先選 1 張作為選莊牌'};
      if (!isAllFilled(head) || !isAllFilled(mid) || !isAllFilled(tail)) return {ok:false, msg:'請先把頭/中/尾墩放滿（2/3/3）'};
      const used = new Set([...head,...mid,...tail].map(cardKey));
      if (used.size !== 8) return {ok:false, msg:'牌重複或有問題，請重排'};
      const dk = cardKey(clientState.dealerCard);
      if (used.has(dk)) return {ok:false, msg:'選莊牌不可放入頭/中/尾墩，請更換'};
      // 允許「擺烏龍」提交（結算時會依規則處理）
      return {ok:true};
    }

    function submitArrangement() {
      const v = validateArrangement();
      if (!v.ok) { toast(v.msg); return; }

      const payload = {
        t:'submit',
        dealerCard: clientState.dealerCard,
        head: clientState.arranged.head,
        mid: clientState.arranged.mid,
        tail: clientState.arranged.tail,
        report: $('selReport').value || 'none',
      };

      if (isHost) {
        const ok = validateSubmissionAgainstDeal(hostId, payload);
        if (!ok.ok) {
          toast(ok.msg);
          return;
        }
        hostState.submissions[hostId] = { dealerCard: payload.dealerCard, head: payload.head, mid: payload.mid, tail: payload.tail, report: payload.report };
        glog('你已提交排牌');
        $('submitStatus').textContent = '已提交';
        $('submitStatus').className = 'text-xs text-emerald-200';
        clientState.submitted = true;
        stopArrangeTimer();

        // auto close arrange modal back to table
        try { closeArrangeModal(); } catch {}

        const rmap = readyMapForBroadcast();
        broadcast({t:'ready', ready: rmap});
        // update host local ready map for seat tick
        try { clientState.readyMap = rmap; } catch {}
        try { renderTableSeats(); } catch {}
        renderReadyList(rmap);

        if (allSubmitted()) {
          const controller = findDealerPickController(hostState.submissions);
          if (controller) {
            hostState.dealerPick = { ...controller, round: hostState.round, startedAt: Date.now() };
            hostState.dealerOverride = null;
            const ctx = {
              t: 'dealerPickStart',
              round: hostState.round,
              controllerId: controller.controllerId,
              kind: controller.kind,
              submissions: sanitizeSubsForBroadcast(),
              players: allPlayersForBroadcast(),
            };
            if (controller.controllerId === hostId) {
              openDealerPickPreModal({
                round: ctx.round,
                kind: ctx.kind,
                controllerId: ctx.controllerId,
                submissions: ctx.submissions,
                players: ctx.players,
                currentDealerId: hostId,
              });
              toast('你持有鬼牌：請在結算前指定莊家');
            } else {
              const p = hostState.players[controller.controllerId];
              if (p?.conn) send(p.conn, ctx);
              toast('等待鬼牌玩家指定莊家…');
              log(`等待 ${hostState.players[controller.controllerId]?.name || controller.controllerId} 指定莊家`);
            }
          } else {
            revealRound();
          }
        }
        return;
      }

      if (!clientState.connected || !clientState.roomId || !clientConn) {
        toast('尚未連線到房主');
        return;
      }

      try {
        send(clientConn, payload);
        clientState.submitted = true;
        try {
          clientState.readyMap = { ...(clientState.readyMap || {}), [myId]: true };
        } catch {}
        stopArrangeTimer();
        $('submitStatus').textContent = '已提交';
        $('submitStatus').className = 'text-xs text-emerald-200';
        glog('已送出提交');

        // auto close arrange modal back to table
        try { closeArrangeModal(); } catch {}
        try { renderTableSeats(); } catch {}
        renderReadyList(clientState.readyMap || null);
      } catch (e) {
        toast('提交失敗：連線錯誤');
      }
    }

    // -------------------- Connect flows --------------------
    let clientConn = null; // persistent connection from client -> host

    function generateRoomId() {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let out = '';
      for (let i = 0; i < 6; i += 1) {
        out += chars[Math.floor(Math.random() * chars.length)];
      }
      return out;
    }

    function becomeHost() {
      ensureName();
      isHost = true;
      hostId = null;

      let custom = ($('inpCustomRoomId')?.value || '').trim();
      if (!custom) custom = generateRoomId();
      const ok = /^[a-zA-Z0-9_-]{3,32}$/.test(custom);
      if (!ok) {
        toast('自訂房間號格式不正確：請用 3～32 字的英數/底線/減號');
        return;
      }
      hostRoomId = custom.toUpperCase();
      clientState.roomId = hostRoomId;

      setBadge(false, '建立中…');
      connectRelay({ type: 'host', roomId: hostRoomId });
      setRoleBadges();
      log(`正在建立房間：${hostRoomId} …`);
    }

    function joinRoom(roomId) {
      // stop previous keepalive/reconnect
      try { stopClientHeartbeat(); } catch {}
      try {
        if (clientReconnectTimer) {
          clearTimeout(clientReconnectTimer);
          clientReconnectTimer = null;
        }
      } catch {}
      clientReconnectAttempts = 0;

      ensureName();
      let rid = String(roomId || '').trim();
      // remove invisible spaces that may break peer id parsing
      rid = rid.replace(/[\u200B-\u200D\uFEFF]/g, '').trim();
      if (!rid) { toast('請輸入房間號'); return; }

      // "Old" stable join behavior:
      // - Do NOT call resetAll() here (it wipes too much UI state and can cause DOM-id null errors)
      // - Instead, teardown only networking objects and keep the UI/input intact.
      try {
        if (clientConn) { try { clientConn.close(); } catch {} }
      } catch {}
      clientConn = null;

      closeRelaySocket();
      myId = null;

      isHost = false;
      hostId = null;
      clientState.roomId = rid;
      clientState.players = {};
      clientState.connected = false;
      clientState.joining = true;
      setBadge(false, '連線中…');

      connectRelay({ type: 'join', roomId: rid });
      setRoleBadges();
      renderPlayers();
      log(`正在加入房間：${rid} … (${JSON.stringify(rid)})`);

      setTimeout(() => {
        if (clientState.connected || !clientState.joining) return;
        clientState.joining = false;
        toast('加入房間逾時：請確認房主已建立房間且網路可用');
        setBadge(false, '逾時');
      }, 14000);
    }

    // -------------------- URL helper --------------------
    function updateShareLink(roomId) {
      if (location.protocol === 'file:') {
        throw new Error('目前是以本機檔案(file://)開啟，無法跨裝置分享連結。請用 http(s) 方式部署後再分享。');
      }
      const base = location.origin + location.pathname;
      const url = new URL(base);
      url.searchParams.set('room', roomId);
      return url.toString();
    }

    // -------------------- Event bindings --------------------
    $('btnSaveName').addEventListener('click', () => {
      ensureName();
      toast('已儲存暱稱');
      renderPlayers();
    });

    $('btnCreateRoom').addEventListener('click', () => {
      // Persist TURN toggle
      try {
        const cfg = loadNetConfig();
        cfg.useTurn = !!$('chkUseTurn')?.checked;
        saveNetConfig(cfg);
      } catch {}

      // Use inpRoomId as optional custom room id (create)
      try {
        let v = ($('inpRoomId')?.value || '').trim();
        if (!v) v = 'MON'; // 若留空，強制設定為 MON

        $('inpCustomRoomId').value = v;
      } catch {}

      if (relaySocketOpen()) resetAll();
      becomeHost();
    });

    $('btnJoinRoom').addEventListener('click', () => {
      // Persist TURN toggle
      try {
        const cfg = loadNetConfig();
        cfg.useTurn = !!$('chkUseTurn')?.checked;
        saveNetConfig(cfg);
      } catch {}

      let rid = ($('inpRoomId').value || '').trim();
      
      // 原本是： if (!rid) return toast('請輸入房間號');
      // 修改為： 若留空，自動設為 MON
      if (!rid) {
        rid = 'MON';
      }
      
      if (relaySocketOpen()) resetAll();
      joinRoom(rid);
    });

    $('btnLeave').addEventListener('click', () => {
      resetAll();
      showPage('lobby');
    });

    $('btnCopyRoom').addEventListener('click', async () => {
      const room = hostRoomId || clientState.roomId;
      if (!room) return;
      await navigator.clipboard.writeText(room);
      toast('已複製房間號');
    });

    $('btnCopyLink').addEventListener('click', async () => {
      const rid = (isHost ? hostRoomId : clientState.roomId) || clientState.roomId;
      if (!rid) return toast(isHost ? '請先建立房間（取得房間號）' : '尚未取得房間號');
      try {
        const link = updateShareLink(rid);
        await navigator.clipboard.writeText(link);
        toast('已複製分享連結（打開即可自動加入）');
      } catch (e) {
        toast(e?.message || '無法產生分享連結');
      }
    });

    // Scoreboard (Lobby)
    $('btnOpenScoreboard')?.addEventListener('click', (e) => {
      e.preventDefault();
      openScoreboardModal();
    });
    $('btnCloseScoreboard')?.addEventListener('click', closeScoreboardModal);
    $('scoreboardBackdrop')?.addEventListener('click', closeScoreboardModal);
    $('btnTabDay')?.addEventListener('click', () => setScoreboardTab('DAY'));
    $('btnTabNig')?.addEventListener('click', () => setScoreboardTab('MON'));
    $('btnScoreboardRefresh')?.addEventListener('click', () => loadScoreboard(true));

    // App update button (lobby)
    $('btnUpdateApp')?.addEventListener('click', (e) => {
      e.preventDefault();
      applyAppUpdate();
    });

    // Advanced net config
    const chkUseTurnEl = $('chkUseTurn');
    if (chkUseTurnEl) {
      chkUseTurnEl.addEventListener('change', () => {
        try {
          const cfg = loadNetConfig();
          cfg.useTurn = !!chkUseTurnEl.checked;
          saveNetConfig(cfg);
        } catch {}
      });
    }

    const btnSaveNet = $('btnSaveNet');
    const btnClearNet = $('btnClearNet');
    const btnTestTurn = $('btnTestTurn');
    if (btnSaveNet) {
      btnSaveNet.addEventListener('click', () => {
        const cfg = {
          useTurn: !!$('chkUseTurn')?.checked,
          turnUrl: ($('inpTurnUrl')?.value || '').trim(),
          turnUser: ($('inpTurnUser')?.value || '').trim(),
          turnPass: ($('inpTurnPass')?.value || '').trim(),
          relayOnly: !!$('chkRelayOnly')?.checked,
        };
        saveNetConfig(cfg);
        setTurnTestStatus('TURN 測試：尚未測試');
        toast('已儲存進階連線設定（請離開/重置後再重新連線）');
      });
    }
    if (btnClearNet) {
      btnClearNet.addEventListener('click', () => {
        saveNetConfig({ ...DEFAULT_NET_CONFIG });
        applyNetConfigToUI();
        setTurnTestStatus('TURN 測試：尚未測試');
        toast('已恢復預設 TURN（請離開/重置後再重新連線）');
      });
    }
    if (btnTestTurn) {
      btnTestTurn.addEventListener('click', () => {
        // Read current UI first so user doesn't have to press save.
        const cfg = {
          useTurn: true, // testing TURN implies enable
          turnUrl: ($('inpTurnUrl')?.value || '').trim(),
          turnUser: ($('inpTurnUser')?.value || '').trim(),
          turnPass: ($('inpTurnPass')?.value || '').trim(),
          relayOnly: true, // force relay for test
        };
        testTurnServer(cfg);
      });
    }

    $('btnApplyRounds').addEventListener('click', () => {
      if (!isHost) return;
      hostApplyRounds();
    });

    $('inpRounds').addEventListener('change', () => {
      if (!isHost) return;
      hostApplyRounds();
    });

    $('btnStartGame').addEventListener('click', () => startGame());

    // Top-right: Exit room
    $('btnGoLobby').addEventListener('click', () => {
      resetAll();
      showPage('lobby');
    });
    $('btnBackToLobby').addEventListener('click', () => showPage('lobby'));

    $('btnClearLog').addEventListener('click', () => $('log').innerHTML='');
    $('btnClearGameLog').addEventListener('click', () => $('gameLog').innerHTML='');

    $('btnResetArrange').addEventListener('click', () => {
      if (clientState.submitted) return toast('已提交，無法重排');
      resetArrange();
    });
    $('btnAutoFill').addEventListener('click', () => autoFillRandomNoFoul());
    $('btnSubmit').addEventListener('click', () => submitArrangement());

    $('btnReveal').addEventListener('click', () => {
      if (!isHost) return;
      revealRound();
    });

    $('btnNextRound').addEventListener('click', () => {
      if (!isHost) return;
      nextRound();
    });

    $('btnOpenLastReveal').addEventListener('click', () => {
      if (clientState.lastReveal) openRevealModal(clientState.lastReveal);
    });

    $('btnCloseReveal').addEventListener('click', closeRevealModal);
    $('btnCloseReveal2').addEventListener('click', closeRevealModal);
    $('revealBackdrop').addEventListener('click', closeRevealModal);

    // Bottom bar modals
    $('btnOpenStatus').addEventListener('click', () => {
      // In kiosk mode, "狀態/結果" should show the full settlement when available
      if (clientState.lastReveal) {
        openRevealModal(clientState.lastReveal);
      } else {
        openStatusModal();
      }
    });
    $('btnOpenLog').addEventListener('click', openLogModal);
    $('btnMidAction').addEventListener('click', () => {
      // Host: after reveal -> next round. Otherwise: open Arrange (牌組)
      if (isHost && hostState.revealed) {
        nextRound();
      } else {
        openArrangeModal();
      }
    });

    // Bottom bar collapse/expand
    function setBottomBarCollapsed(v) {
      clientState.bottomBarCollapsed = !!v;
      try { localStorage.setItem('ninePokerBottomBarCollapsed', clientState.bottomBarCollapsed ? '1' : '0'); } catch {}
      updateBodyOverflow();
      updateChatUnread();
    }

    $('btnHideBar')?.addEventListener('click', () => setBottomBarCollapsed(true));
    $('btnShowBar')?.addEventListener('click', () => setBottomBarCollapsed(false));

    // Chat send
    $('btnSendChat').addEventListener('click', () => {
      sendChatText($('inpChat').value);
      $('inpChat').value = '';
    });
    $('inpChat').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        sendChatText($('inpChat').value);
        $('inpChat').value = '';
      }
    });
    $('chatQuick').addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-msg]');
      if (!btn) return;
      const msg = btn.dataset.msg;
      // quick msg: keep chat record + force danmaku on all players
      sendChatText(msg);
    });

    // Stickers click handled in initStickers()

    $('btnCloseStatus').addEventListener('click', closeStatusModal);
    $('statusBackdrop').addEventListener('click', closeStatusModal);

    $('btnCloseReport').addEventListener('click', closeReportModal);
    $('btnCloseReport2').addEventListener('click', closeReportModal);
    $('reportBackdrop').addEventListener('click', closeReportModal);

    $('btnCloseLog').addEventListener('click', closeLogModal);
    $('logBackdrop').addEventListener('click', closeLogModal);

    // Arrange modal events
    $('btnOpenArrange').addEventListener('click', openArrangeModal);
    $('btnCloseArrange').addEventListener('click', closeArrangeModal);
    $('btnCloseArrange2')?.addEventListener('click', closeArrangeModal);
    $('arrangeBackdrop').addEventListener('click', closeArrangeModal);

    // Table center button is re-created by renderTableSeats(); its click handler is bound there.

    // Dealer pick (pre-reveal) modal events
    $('btnCloseDealerPickPre').addEventListener('click', closeDealerPickPreModal);
    $('dealerPickPreBackdrop').addEventListener('click', closeDealerPickPreModal);
    $('btnDealerPickPreConfirm').addEventListener('click', () => {
      if (!dealerPickPreCtx) return;
      if (!dealerPickPreSelectedId) {
        toast('請先選擇一位玩家');
        return;
      }

      // If controller is the host (no clientConn), apply locally.
      if (isHost && dealerPickPreCtx.controllerId === hostId) {
        const ids = [hostId, ...Object.keys(hostState.players)];
        if (!ids.includes(dealerPickPreSelectedId)) {
          toast('指定的莊家不在房間內');
          return;
        }
        hostState.dealerOverride = dealerPickPreSelectedId;
        hostState.dealerPick = null;
        broadcast({t:'dealerPickFinal', round: dealerPickPreCtx.round, dealerId: dealerPickPreSelectedId});
        toast('已指定莊家，開始結算');
        closeDealerPickPreModal();
        revealRound();
        return;
      }

      // Controller (player) sends choice to host
      if (!clientConn || !clientState.connected) {
        toast('尚未連線到房主');
        return;
      }
      send(clientConn, {
        t: 'dealerPickChoice',
        pick: {
          round: dealerPickPreCtx.round,
          kind: dealerPickPreCtx.kind,
          dealerId: dealerPickPreSelectedId,
        }
      });
      toast('已送出莊家指定');
      closeDealerPickPreModal();
    });

    // Game over modal events
    $('btnCloseGameOver').addEventListener('click', closeGameOverModal);
    $('gameOverBackdrop').addEventListener('click', closeGameOverModal);

    $('btnExitRoom').addEventListener('click', () => {
      closeGameOverModal();
      resetAll();
      showPage('lobby');
    });

    $('btnRestart').addEventListener('click', () => {
      if (isHost) {
        // host: restart game immediately
        hostState.round = 0;
        hostState.revealed = false;
        hostState.dealt = {};
        hostState.submissions = {};
        hostState.dealerId = null;
        hostState.cumulative = {};

        clientState.cumulative = {};
        updateMyCumulative();

        const payload = { t:'restart', cumulative: hostState.cumulative };
        broadcast(payload);
        closeRevealModal();
        closeGameOverModal();
        glog('房主已重開遊戲');
        nextRound();
      } else {
        // player: request host
        if (!clientConn || !clientState.connected) {
          toast('尚未連線到房主');
          return;
        }
        send(clientConn, {t:'restartRequest'});
        toast('已向房主提出再來一局請求');
      }
    });

    // -------------------- Boot --------------------
    // Prevent pinch-to-zoom (best effort)
    document.addEventListener('gesturestart', (e) => { e.preventDefault(); });
    document.addEventListener('gesturechange', (e) => { e.preventDefault(); });
    document.addEventListener('gestureend', (e) => { e.preventDefault(); });
    document.addEventListener('wheel', (e) => { if (e.ctrlKey) e.preventDefault(); }, { passive: false });
    document.addEventListener('touchstart', (e) => {
      if (e.touches && e.touches.length > 1) e.preventDefault();
    }, { passive: false });
    document.addEventListener('touchmove', (e) => {
      if (e.touches && e.touches.length > 1) e.preventDefault();
    }, { passive: false });

    (function init() {
      // PWA: register service worker (only works on http(s), not file://)
      try {
        const canSw = ('serviceWorker' in navigator) && location.protocol !== 'file:';
        if (canSw) {
          navigator.serviceWorker.register('./sw.js').then((reg) => {
            swReg = reg;
            dlog('PWA: service worker registered');

            // If there is already a waiting worker, prompt update
            if (reg.waiting && navigator.serviceWorker.controller) {
              setUpdateAvailable(true, '有新版本可更新');
            }

            reg.addEventListener('updatefound', () => {
              const nw = reg.installing;
              if (!nw) return;
              nw.addEventListener('statechange', () => {
                if (nw.state === 'installed' && navigator.serviceWorker.controller) {
                  setUpdateAvailable(true, '已下載新版本，點擊更新');
                }
              });
            });

            // When new SW takes control, reload to apply new assets
            navigator.serviceWorker.addEventListener('controllerchange', () => {
              setUpdateAvailable(false);
              try { clearAllCachesBestEffort(); } catch {}
              location.reload();
            });

          }).catch((e) => {
            dlog('PWA: service worker register failed: ' + (e?.message || e));
          });
        } else {
          dlog('PWA: service worker skipped (unsupported or file://)');
        }
      } catch (e) {
        dlog('PWA: init error: ' + (e?.message || e));
      }

      applyNetConfigToUI();
      setTurnTestStatus('TURN 測試：尚未測試');

      // BB mode (disable arrange timer) load
      try {
        const bb = localStorage.getItem('ninePokerBBMode');
        if (bb === '1') {
          clientState.settings.bbMode = true;
          try { $('chkBBMode').checked = true; } catch {}
        }
      } catch {}
      const saved = localStorage.getItem('ninePokerName');
      if (saved) {
        clientState.myName = saved;
        $('inpName').value = saved;
      } else {
        $('inpName').value = clientState.myName;
      }

      const url = new URL(location.href);
      const room = url.searchParams.get('room');
      if (room) {
        $('inpRoomId').value = room;
      }

      // Load bottom bar collapsed state (default: collapsed)
      try {
        const v = localStorage.getItem('ninePokerBottomBarCollapsed');
        if (v === '0') clientState.bottomBarCollapsed = false;
        if (v === '1') clientState.bottomBarCollapsed = true;
      } catch {}

      setRoleBadges();
      renderPlayers();
      showPage('lobby');
      updateBodyOverflow();
      updateChatUnread();
      log('開啟頁面完成。可建立房間或加入房間。');

      // iOS PWA install hint (best-effort)
      try {
        const ua = navigator.userAgent || '';
        const isIOS = /iPhone|iPad|iPod/i.test(ua);
        const isStandalone = (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) || (navigator.standalone === true);
        if (isIOS && !isStandalone) {
          const shown = localStorage.getItem('ninePokerPwaHintShown');
          if (!shown) {
            localStorage.setItem('ninePokerPwaHintShown','1');
            toast('iOS：建議用 Safari「加入主畫面」以 PWA 模式使用（全屏更穩定）');
          }
        }
      } catch {}

      // Show/hide debug panel
      try {
        const dp = $('debugPanel');
        if (dp) dp.classList.toggle('hidden', !DEBUG_ENABLED);
      } catch {}

      // Init stickers for chat
      try { initStickers(); } catch {}

      // Auto-join from share link
      if (room) {
        // joinRoom will reset if needed
        joinRoom(room);
      }

      const hostButtonsWatcher = setInterval(() => {
        if (isHost && relaySocketOpen() && myId) {
          $('btnApplyRounds').classList.remove('hidden');
          $('btnStartGame').classList.remove('hidden');
          clearInterval(hostButtonsWatcher);
        }
      }, 200);
    })();
  </script>
</body>
</html>
